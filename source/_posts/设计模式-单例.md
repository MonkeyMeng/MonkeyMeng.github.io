---
title: 设计模式--单例
date: 2019-04-11 16:28:56
tags:
categories: 设计模式
---
## 应用场景
顾名思义,单例就是某个类在JVM里只有一个实例对象.为什么会产生单例这种设计模式呢,个人理解,从两方面来解释,一方面是性能:假设某个类的实例非常重量,每次实例化耗时耗资源,那么我们考虑将这个实例在堆中只维护一份,比如我们的系统常常有读取配置文件的需求,那么我们完全可以只读一次就把配置文件中的内容加载进JVM以对象的形式维护,处于性能考虑,没必要每次都是实例化;另一方面是逻辑,比如数据库连接池,或者XXXManager这些管理类型的类,一个系统中有一个就够了,就好比一个房子有一个大管家就可以了,两个就容易打架,处于这种逻辑考虑,可以运用单例的设计模式来处理.
## 举例
就拿上面的读取配置文件的例子来学习一下单例模式,假设我们有一个系统,需要和微信对接,获取用户的微信头像,那么我们肯定得知道微信的服务地址吧,写死在程序里这种硬编码的方式可维护性比较差,所以我们可以考虑把微信的接口地址配到配置文件中,然后通过代码把配置读进来,实例化一个配置类:
配置文件config.properties:
 {% codeblock lang:js %}
 	#微信接口地址
 	wechatUrl = https://xxx/xxx/xxx
 	#除了url有可能会有一些其他的配置用来进行参数签名之类的
 	wechatKey = xxxxxx
 	wechatSecret = xxxxxx
 {% endcodeblock %}
下面我们用一个单例模式来实现上述读取配置文件的过程:
 {% codeblock lang:java %}
package com.crazymonkey.singleton;
import java.util.Properties;
/**
 * 配置文件读取类
 */
public class ConfigConstants {

    private String wechatUrl = "";

    private String wechatKey = "";

    private String wechatSecret = "";

    private static ConfigConstants instance;

    public String getWechatUrl() {
        return wechatUrl;
    }

    public String getWechatKey() {
        return wechatKey;
    }

    public String getWechatSecret() {
        return wechatSecret;
    }

    //暴露一个public类型的get方法用来获取实例信息
    public static ConfigConstants getInstance() {
        try {
            if (instance == null) {
                instance = new ConfigConstants();
            }
            return instance;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public String toString() {
        return "ConfigConstants{" +
                "wechatUrl='" + wechatUrl + '\'' +
                ", wechatKey='" + wechatKey + '\'' +
                ", wechatSecret='" + wechatSecret + '\'' +
                '}';
    }

    private ConfigConstants() throws Exception {
        Properties properties = new Properties();
        properties.load(Object.class.getResourceAsStream("/config.properties"));
        this.wechatUrl = properties.getProperty("wechatUrl", "");
        this.wechatKey = properties.getProperty("wechatKey", "");
        this.wechatSecret = properties.getProperty("wechatSecret", "");
    }

    public static void main(String[] args) {
        ConfigConstants c1 = ConfigConstants.getInstance();
        ConfigConstants c2 = ConfigConstants.getInstance();
        System.out.println(c1.equals(c2));
        System.out.println(c1.toString());
    }
}
 {% endcodeblock %}
 看一眼运行的结果:
 <img src="设计模式-单例/singletonresult.png">
 我们可以发现两次取得的是同一个实例,针对上面的例子我们可以总结单例的创建过程:
 1. **私有的构造方法**:防止该类在别处被实例化:
 2. **本类中定义一个static对象**:有人会问,为什么是static类型?个人理解:不考虑反射或者反序列化等特殊创建对象的方式(后面会提),我们只考虑常规的访问成员变量的方式有两种:第一种是通过new关键字创建一个对象,然后访问对象中的属性;另一种方式是直接通过类名来访问该类的静态变量,构造方法私有化之后我们无法在外部通过对象实例的方式访问该对象的成员属性,那么我们只能通过类名.方法名的方式来访问,所以就要求方法是static的,static的方法又不能直接拿非static的引用,因此必须要求成员变量instance是static的.
 3. **提供可访问该对象的公有方法**;




## 单例与静态类


## 单例的写法


## 单例的破坏
