---
title: 设计模式--建造者
date: 2019-04-15 16:29:23
tags:
categories: 设计模式
---
## 应用场景
建造者,是构建对象的时候用的一种设计模式,有的人说,构建对象直接new就可以了,怎么还有设计模式呢.如果一个类的结构比较简单,那么我们可以直接new创建对象,但是如果一个类的构建比较复杂,构建这个类的对象的时候比较费劲,那么就可以使用建造者模式,我们举几个开发中的例子来说明一下.
## 举例1
我们在工作中肯定会遇到分页查询的场景,由于返回的数据结构固定,因此我们可以定义一个分页类来进行封装:
{% codeblock lang:java %}
package com.crazymonkey.builder;

import java.util.List;

/**
 * 分页实体
 */
public class Pagination<T> {

    //当前页
    private int currentPage;
    //每页条数
    private int pageSize;
    //总条数
    private int totalLines;
    //总页数
    private int totalPages;
    //数据信息
    List<T> data;

    //忽略getters and setters
}
 {% endcodeblock %}

我们在使用分页的时候可能会
{% codeblock lang:java %}
 	//内部类,用来模拟从数据库中查出来的实体
  private class User{
        private String userId;
        private String userName;

    }
    public static void main(String[] args) {
    	//分页的使用 重点关注下这里
        List<Pagination.User> users = new ArrayList<>();
        Pagination page = new Pagination<>();
        page.setCurrentPage(0);
        page.setPageSize(10);
        page.setTotalLines(100);
        page.setTotalPages(10);
        page.setData(new ArrayList<Pagination.User>());
    }
 {% endcodeblock %}
## 分析
万变不离其宗嘛,我们还是从设计原则来分析一下,main方法作为调用者来讲,他的目的就是为了获取一个pagination对象,在这个过程中他其实不需要关注对象的**构造细节**,什么是构造细节,就是对象包含什么属性,到底是怎么赋值的.有人说,那好办啊,java的三大特性之首,封装,我们把实现细节封起来不就得了么,怎么封呢---最简单的方式:构造方法呗,
{% codeblock lang:java %}
	//构造方法
  Pagination(int currentPage,int pageSize,int totalLines,int totalPages,List<T> data){
        this.currentPage = currentPage;
        this.pageSize = pageSize;
        this.totalLines = totalLines;
        this.totalPages = totalPages;
        this.data = data;
    }
    //具体调用
    public static void main(String[] args) {
        List<Pagination.User> users = new ArrayList<>();
        Pagination page = new Pagination<>(0,10,100,10,new ArrayList<Pagination.User>());
    }
{% endcodeblock %}
调用的地方变成了一行,美滋滋,但是突然有个需求,返回的分页实体中要扩展一个type字段,用来标示前端要用哪种展示方式(不讨论需求合理性,只进行简单扩展)我们就需要修改构造方法,或者重载构造方法.每次需求变更都要重新修改构造方法,并修改调用者的代码,如果参数很多的情况下构造函数也会显得杂乱且不好维护
## 应用
所以我们考虑引入建造者类来帮我们处理构造过程:
{% codeblock lang:java %}
	//考虑引入静态内部类
    private static class Builder{
        private Pagination pagination;

        public Builder(Pagination p){this.pagination = p;}
        public Builder buildCurrentPage(int currentPage){
            this.pagination.currentPage=currentPage;
            return this;
        }
        public Builder buildPageSize(int pageSize){
            this.pagination.pageSize=pageSize;
            return this;
        }
        public Builder buildTotalLines(int totalLines){
            this.pagination.totalLines=totalLines;
            return this;
        }
        public Builder buildTotalPages(int totalPages){
            this.pagination.totalPages=totalPages;
            return this;
        }
        public Builder buildData(List data){
            this.pagination.data=data;
            return this;
        }
        public Pagination build(){
            return this.pagination;
        }

    }
    //具体调用
    public static void main(String[] args) {
        Pagination page = new Pagination.Builder(new Pagination()).buildCurrentPage(0).buildPageSize(10).buildTotalLines(100).build();
    }
{% endcodeblock %}
## 分析
从上面的调用过程我们可以看到,如果此时增加需求,并不需要重载构造方法,只需要修改建造者类就可以了.这样修改的话有两点好处,一是逻辑比较清晰,客户端-->建造者-->对象,将建造的职责抽离出来;二是这种类似于流式的编程方式让我感觉很爽,简洁.但是从根本上来看,调用者实际上仍然参与了具体对象的构造细节,如果需求扩展的话,我们仍然需要修改调用者的调用代码.我们可以说这是建造者的一种应用场景,能帮我们实现一种流式编程方式,但是从面相对象的角度来讲,这种应用场景对于代码架构来讲,并没有实质上的提升.
## 举例2

