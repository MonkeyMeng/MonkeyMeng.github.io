[{"title":"设计模式--建造者","url":"/2019/04/15/设计模式-建造者/","content":"## 应用场景\n建造者,是构建对象的时候用的一种设计模式,有的人说,构建对象直接new就可以了,怎么还有设计模式呢.如果一个类的结构比较简单,那么我们可以直接new创建对象,但是如果考虑一些构造方法的变化和业务的扩展,就会体现出建造者模式的优点.\n## 举例1\n我们在工作中肯定会遇到分页查询的场景,由于返回的数据结构固定,因此我们可以定义一个分页类来进行封装:\n{% codeblock lang:java %}\npackage com.crazymonkey.builder;\n\nimport java.util.List;\npublic class Pagination<T> {\n\n    //当前页\n    private int currentPage;\n    //每页条数\n    private int pageSize;\n    //总条数\n    private int totalLines;\n    //总页数\n    private int totalPages;\n    //数据信息\n    List<T> data;\n\n    //忽略getters and setters\n}\n {% endcodeblock %}\n\n我们在使用分页的时候就直接构造呗\n{% codeblock lang:java %}\n \t//内部类,用来模拟从数据库中查出来的实体\n  private class User{\n        private String userId;\n        private String userName;\n\n    }\n    public static void main(String[] args) {\n    \t//分页的使用 重点关注下这里\n        List<Pagination.User> users = new ArrayList<>();\n        Pagination page = new Pagination<>();\n        page.setCurrentPage(0);\n        page.setPageSize(10);\n        page.setTotalLines(100);\n        page.setTotalPages(10);\n        page.setData(new ArrayList<Pagination.User>());\n    }\n {% endcodeblock %}\n## 分析\n我们还是从设计原则来分析一下,main方法作为调用者来讲,他的目的就是为了获取一个pagination对象,在这个过程中他其实不需要关注对象的**构造细节**,什么是构造细节,就是对象包含什么属性,到底是怎么赋值的.有人说,那好办啊,java的三大特性之首,封装,我们把实现细节封起来不就得了么,怎么封呢---最简单的方式:构造方法呗,\n{% codeblock lang:java %}\n\t//构造方法\n  Pagination(int currentPage,int pageSize,int totalLines,int totalPages,List<T> data){\n        this.currentPage = currentPage;\n        this.pageSize = pageSize;\n        this.totalLines = totalLines;\n        this.totalPages = totalPages;\n        this.data = data;\n    }\n    //具体调用\n    public static void main(String[] args) {\n        List<Pagination.User> users = new ArrayList<>();\n        Pagination page = new Pagination<>(0,10,100,10,new ArrayList<Pagination.User>());\n    }\n{% endcodeblock %}\n调用的地方变成了一行,美滋滋,但是突然有个需求,返回的分页实体中要扩展一个type字段,用来标示前端要用哪种展示方式(不讨论需求合理性,只进行简单扩展)我们就需要修改构造方法,或者重载构造方法.每次需求变更都要重新修改构造方法,并修改调用者的代码,如果参数很多的情况下构造函数也会显得杂乱且不好维护\n## 应用\n所以我们考虑引入建造者类来帮我们处理构造过程:\n{% codeblock lang:java %}\n\t//引入静态内部类(如果定义成外部类也一样,体会思想即可)\n    private static class Builder{\n\n        private Pagination pagination;\n\n        public Builder(Pagination p){this.pagination = p;}\n        public Builder buildCurrentPage(int currentPage){\n            this.pagination.currentPage=currentPage;\n            return this;\n        }\n        public Builder buildPageSize(int pageSize){\n            this.pagination.pageSize=pageSize;\n            return this;\n        }\n        public Builder buildTotalLines(int totalLines){\n            this.pagination.totalLines=totalLines;\n            return this;\n        }\n        public Builder buildTotalPages(int totalPages){\n            this.pagination.totalPages=totalPages;\n            return this;\n        }\n        public Builder buildData(List data){\n            this.pagination.data=data;\n            return this;\n        }\n        public Pagination build(){\n            return this.pagination;\n        }\n    }\n    //具体调用\n    public static void main(String[] args) {\n        Pagination page = new Pagination.Builder(new Pagination()).buildCurrentPage(0).buildPageSize(10).buildTotalLines(100).build();\n    }\n{% endcodeblock %}\n## 分析\n从上面的调用过程我们可以看到,如果此时增加需求,并不需要重载构造方法,只需要修改建造者类就可以了.这样修改的话有两点好处,一是逻辑比较清晰,客户端-->建造者-->对象,将建造的职责抽离出来;二是这种类似于流式的编程方式让我感觉很爽,简洁.但是从根本上来看,调用者实际上仍然参与了具体对象的构造细节,如果需求扩展的话,我们仍然需要修改调用者的调用代码.我们可以说这是建造者的一种应用场景,能帮我们实现一种流式编程方式,但是从面向对象的角度来讲,这种应用场景下的建造者模式对于代码架构来讲,并没有实质上的提升.\n## 举例2\n个人理解:**建造者模式更适合对象的组成相对固定,构建流程相对固定,但表现不固定的情况**  举个例子来讲,我们用的很多软件并非大而全,真正厉害的是他们的插件,各种各样的插件提供丰富的功能,比如zsh/sublime/eclipse/idea,老外的设计思想很多就是**面向接口编程**,我只提供标准,那么基于这个标准我可以进行各种扩展.我们就举一个最简单的主题插件的例子,用idea或eclipse的都知道可以换主题,github上也有大量的主题配置文件,假如让我们来设计这种换主题的操作,我们怎么搞:\n### 第一步 抽象概念\n主题包括啥?背景(颜色,图片,...)/字体(颜色,字号,字体...)/代码高亮(语言,模板,...)/动态效果(...)\n{% codeblock 主题类 lang:java %}\npackage com.crazymonkey.builder;\n\n/**\n * 主题类,是我们要构造的最终对象 包含上面提到的实体\n */\npublic class Theme {\n\npackage com.crazymonkey.builder;\n/**\n * 主题类,是我们要构造的最终对象\n */\npublic class Theme {\n    //背景\n    private BackGround backGround;\n    //字体\n    private Font font;\n    //代码高亮\n    private CodeHighLight codeHighLight;\n\n    public BackGround getBackGround() {\n        return backGround;\n    }\n    public void setBackGround(BackGround backGround) {\n        this.backGround = backGround;\n    }\n    public Font getFont() {\n        return font;\n    }\n    public void setFont(Font font) {\n        this.font = font;\n    }\n    public CodeHighLight getCodeHighLight() {\n        return codeHighLight;\n    }\n    public void setCodeHighLight(CodeHighLight codeHighLight) {\n        this.codeHighLight = codeHighLight;\n    }\n}\n{% endcodeblock %}\n\n{% codeblock 背景类 lang:java %}\npackage com.crazymonkey.builder;\n\npublic class BackGround {\n\n    //背景颜色\n    private String color;\n    //背景图片地址\n    private String imageUrl;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getImageUrl() {\n        return imageUrl;\n    }\n\n    public void setImageUrl(String imageUrl) {\n        this.imageUrl = imageUrl;\n    }\n}\n{% endcodeblock %}\n\n\n{% codeblock 字体类 lang:java %}\npackage com.crazymonkey.builder;\n\npublic class Font {\n    //字体颜色\n    private String color;\n    //字号\n    private String size;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getSize() {\n        return size;\n    }\n\n    public void setSize(String size) {\n        this.size = size;\n    }\n}\n\n{% endcodeblock %}\n\n{% codeblock 代码高亮类 lang:java %}\npackage com.crazymonkey.builder;\n\nimport java.util.Map;\n\npublic class CodeHighLight {\n    //语言对应的模版id\n    private Map<String,String> langTemplateMap;\n\n    //是否开启代码高亮\n    private boolean effective;\n\n    public Map<String, String> getLangTemplateMap() {\n        return langTemplateMap;\n    }\n\n    public void setLangTemplateMap(Map<String, String> langTemplateMap) {\n        this.langTemplateMap = langTemplateMap;\n    }\n\n    public boolean isEffective() {\n        return effective;\n    }\n\n    public void setEffective(boolean effective) {\n        this.effective = effective;\n    }\n}\n{% endcodeblock %}\n### 开始构造\n我们已经有了基础的数据结构和简单的构成关系,现在我们想创建一个Theme类怎么搞呢,如果你还说new一个Theme对象,然后一个一个set属性,那么请面壁十分钟.我们在整个关系体系中抽象出一个建造者的概念用来实现Theme对象的构造:\n{% codeblock 抽象主题建造者类 lang:java %}\n\tpackage com.crazymonkey.builder;\n\n\tpublic interface ThemeBuilder {\n\n\t    void buildBackGround();\n\n\t    void buildFont();\n\n\t    void buildCodeHighLight();\n\n\t    Theme build();\n\t}\n\n{% endcodeblock %}\nOK 假设我是Idea的开发者我的工作就做完了,我就定义一个接口,给你提供约束,告诉你们一个主题都有哪些组成部分,最终要构建成个什么样子,具体你们想开发成啥样就啥样呗,比如我们按照上面的约定,实现一个亮色主题:\n{% codeblock lang:java %}\n\tpackage com.crazymonkey.builder;\n\n\timport java.util.HashMap;\n\n\tpublic class LightThemeBuilder implements  ThemeBuilder {\n\n\t    Theme theme;\n\n\t    LightThemeBuilder(Theme theme){\n\t        this.theme =  theme;\n\t    }\n\t    @Override\n\t    public void buildBackGround() {\n\t        BackGround bg = new BackGround();\n\t        bg.setColor(\"black\");\n\t        bg.setImageUrl(\"http://xxxx/xxx\");\n\t        theme.setBackGround(bg);\n\t    }\n\n\t    @Override\n\t    public void buildFont() {\n\t        Font font = new Font();\n\t        font.setColor(\"green\");\n\t        font.setSize(\"12\");\n\t        theme.setFont(font);\n\t    }\n\n\t    @Override\n\t    public void buildCodeHighLight() {\n\t        CodeHighLight chl = new CodeHighLight();\n\t        chl.setEffective(true);\n\t        chl.setLangTemplateMap(new HashMap<>());\n\t        theme.setCodeHighLight(chl);\n\t    }\n\n\t    @Override\n\t    public Theme build() {\n\t        return theme;\n\t    }\n\t}\n{% endcodeblock %}\n在这里演示的只是简单的new一个背景对象,字体对象什么的,其实对象的各种属性值完全可以从配置文件读取啊,从数据库读取啊,然后你再把你需要的配置文件什么的和你的代码打个包,放到人家指定的位置,一个主题插件不就完成了么.我们看下调用者:\n{% codeblock lang:java %}\n    public static void main(String[] args) {\n        ThemeBuilder tb = new LightThemeBuilder(new Theme());\n        tb.buildBackGround();\n        tb.buildCodeHighLight();\n        tb.buildFont();\n        Theme theme = tb.build();\n        System.out.println(theme);\n    }\n{% endcodeblock %}\n### 分析\n其实我们实际上是用一个继承关系来屏蔽了Theme对象的具体构造细节,我们只需要告诉具体建造者,给我造背景,但是不需要指定造什么样的背景,实际上是将构造Theme对象的职责抽象到各种水平扩展的构造者身上,但是作为调用者来讲,我们最终只获取Theme对象,并不关心是怎么造出来的,所以我们引入一个指挥官的概念.\n### 指挥官\n{% codeblock lang:java %}\n\t  package com.crazymonkey.builder;\n\n\t\tpublic class ThemeBuildDirector {\n\n\t    ThemeBuilder tb;\n\n\t    ThemeBuildDirector(ThemeBuilder tb){\n\t        this.tb = tb;\n\t    }\n\n\t    public Theme direct(){\n\t        tb.buildFont();\n\t        tb.buildCodeHighLight();\n\t        tb.buildBackGround();\n\t        return tb.build();\n\t    }\n\t}\n{% endcodeblock %}\n这时候,调用者只需要告诉指挥官,我需要一个什么样的Theme,那么指挥官就会调用具体的建造者去造了,而且调用者完全不需要关注对象的建造细节,也不用担心造的部件不完整,这一切都是由指挥官管辖,如果增加需求的话,也不会影响调用者的逻辑,而是由指挥官进行具体建造任务的协调.\n{% codeblock lang:java %}\n public static void main(String[] args) {\n        Theme theme = new ThemeBuildDirector(new LightThemeBuilder(new Theme())).direct();\n        System.out.println(theme);\n    }\n{% endcodeblock %}\n看一眼结果:\n<img src=\"设计模式-建造者/builderresult.png\">\n看完这个例子再看我前面说的那句话,就不难理解了,一个Theme组成部分相对固定,字体啊,背景啊什么的,并且建造流程相对固定,就是造那几部分内容呗,但是表现不固定,什么是表现,就是不同Theme对象的业务形态:白的,黑的,绿的.这种情况我们用建造者可以做到很好的扩展和动态替换.\n\n## 总结\n上面的两个例子实际上是建造者的两种不同的应用场景,我们通过用这种设计模式来达成特定的效果,其实所有设计模式都是一样,有的时候我们可能只需要用到其中的一部分思想就可以了,没必要生搬硬套,掌握设计模式的原则即可.我们再回头看下设计模式的那几项原则,理解一下再建造者模式上的体现,思考一下是怎么一步步封装职责,做到动态替换的,相信你会对设计思想有更深层次的理解.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["设计模式"]},{"title":"设计模式-理论基础","url":"/2019/04/11/设计模式-理论基础/","content":"\n&emsp;&emsp;各种设计模式实际上就是一种前人总结的代码设计的经验之谈,是一种编程的思维方式.运用他们可以帮我们写出简洁可扩展性强的代码.  \n&emsp;&emsp;网上的设计模式的文章大多都是举一两个简单的例子进行解释,但是不可否认 有的时候demo和实际应用场景还有一些距离,虽然明白了原理,但是真到了实际写代码的过程中不知道怎么用.遇到了冗余代码想优化也无从下手.这个设计模式的专题目的就是尽量结合实际项目的应用场景,对常用的设计模式进行举例说明,使得使用者对于各种常用设计模式有着更直观的认识.  \n下面是一些设计原则和方法论,刚开始可能理解的不深,但是熟悉了几个常用的设计模式之后,回头看这些抽象的总结就会发现,所有的设计模式都是这些方法论的具体实践,我们不讲理论,我们只是理论的搬运工:\n- 单一职责原则  \n- 开放封闭原则\n- 里氏替换原则\n- 依赖倒置原则\n- 接口隔离原则\n- 迪米特法则  \n详细的理论解释请参考:<https://www.cnblogs.com/dolphin0520/p/3919839.html>\n\n\n","categories":["设计模式"]},{"title":"设计模式-工厂","url":"/2019/04/11/设计模式-工厂/","content":"## 应用场景\n&emsp;&emsp;工厂是干嘛的,生产东西的呗,生产东西干什么,用呗.这个逻辑平移到编码领域,更确切的说OO编码,工厂是用来干嘛的,生产对象的,生产对象干什么,实现特定的功能,为什么对象不直接New要通过工厂生产--Ok,举个例子看一下.\n&emsp;&emsp;你看到一个视频微博“2019年常规赛詹姆斯精彩镜头”,你知道怎么来的么?实际上背后有一个视频剪辑平台,视频编辑把一个个的镜头挑出来->剪成一个个小段->拼接->给视频起名字->推送到新浪微博.这些过程抽象一下实际上就是一个个的任务,比如我们设计一个任务表来存这些任务 任务类型分别叫 SPLIT(剪辑)->COMPOSE(拼接)->RENAME(起名字)->PUSH(推送) 编辑们干活的时候数据库产生很多条任务记录需要处理 这些任务分属于不同任务类型 这时候来吧 写代码处理一下这些任务吧\n## 处理\n刚上来可能这么处理,下面这个taskList模拟从数据库取出来的任务列表:\n\n {% codeblock lang:java %}\n\tpackage com.crazymonkey;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\tpublic class TestPattern {\n    //模拟任务类\n    class Task {\n        //任务类型\n        String taskType;\n        //视频Id\n        String targetId;\n        Task(String taskType, String targetId) {\n            this.taskType = taskType;\n            this.targetId = targetId;\n        }\n    }\n    public static void main(String[] args) {\n        //*********准备数据开始********\n        List<Task> taskList = new ArrayList<>();\n        TestPattern tp = new TestPattern();\n        taskList.add(tp.new Task(\"SPLIT\", \"111\"));\n        taskList.add(tp.new Task(\"COMPOSE\", \"222\"));\n        taskList.add(tp.new Task(\"RENAME\", \"111\"));\n        taskList.add(tp.new Task(\"TEST\", \"111\"));\n        taskList.add(tp.new Task(\"PUSH\", \"222\"));\n        taskList.add(tp.new Task(\"PUSH\", \"333\"));\n        //********准备数据结束 下面是核心代码*********\n        for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理拆条任务-->\" + task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理合成任务-->\" + task.targetId);\n            } else if (\"RENAME\".[[equalsIgnoreCase]](task.taskType)) {\n                System.out.println(\"处理起名任务-->\" + task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理推送任务-->\" + task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n    }\n\t}\n {% endcodeblock %}\n## 分析\n我们反过来从基础篇的设计原则看一下 这样写为什么不好:  \n1.这个方法处理了所有逻辑,对象职责不清晰,调用者和功能提供者之间职责不清晰\n2.如果这时候业务需求改了增加一个审核的任务类型怎么办,就得改现有代码增加if判断\n3.具体实现逻辑我只输出了一行,但真实的业务场景的复杂逻辑针对每一种任务都得有很多代码来处理,加一起得写多少代码,一旦重命名任务报错想排查的话怎么搞,想死的心都有了吧  \n## 改进\n&emsp;&emsp;在代码优化的过程中最基础有效的首先就是***单一职责***,对象的单一职责和方法的单一职责,第一步先保证一个对象只干一件事:\n {% codeblock  lang:java %}\n    for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandler().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n               new ComposeTaskHandler().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandler().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n              new PushTaskHandler().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n &emsp;&emsp;可以看到我针对每种任务类型分别创建一个对象,并且提供一个handleTask方法来进行处理各自的业务逻辑,随便取一个出来看看,不一一列举了:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler {\n            public void handleTask(String targetId){\n                System.out.println(\"处理拆条任务-->\" + targetId);\n                //真实的处理逻辑 可能有很多行    \n            }\n    }\n  {% endcodeblock %}\n## 分析\n我们解决了一部分问题,分离了一些职责出去,这时候如果拆条任务处理出错了,我们也很好定位了,直接去对应的类里面找代码就可以了,但是还有一些问题待解决:第一,调用者(Main)直接持有每个任务处理类的对象,这是一种强耦合的关系引用;第二,调用者的职责是调用,现在仍然承担了判断该用哪个Handler的职责;第三,每个Handler都有相同的行为,就是处理任务,我们可以对他们进行更抽象的约束.为了解决这三点问题,我们先来看下简单工厂模式:\n## 简单工厂模式\n首先 声明一个接口 用来抽象我们上面创建的handler,定义handlerTask方法来处理任务:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface TaskHandler {\n        \n       void handleTask(String targetId);\n    }\n {% endcodeblock %}\n 每个任务的实现类实现该接口,还是拿一个举例:\n   {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler implements TaskHandler {\n        @Override\n        public void handleTask(String targetId){\n            System.out.println(\"处理拆条任务-->\" + targetId);\n            //真实的处理逻辑 可能有很多行\n        }\n    }\n {% endcodeblock %}\n\n然后我们创建一个工厂,用来产生TashHandler,工厂的作用就是分离调用者原本的创建Handler的职责,返回值是TaskHandler,这是一个典型的***面相接口编程***的应用运行时才决定示例化哪个对象 这也就是Java三大特性之一的多态 扯远了看工厂:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class TaskHandlerSimpleFactory {\n        //注意返回值是一个接口类型 \n       static TaskHandler create(String taskType){\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n               return new SplitTaskHandler();\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) { \n                return new ComposeTaskHandler(); \n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n              return new RenameTaskHandler();\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n               return new PushTaskHandler();\n            } else {\n                return null;\n            }\n        }\n    }\n {% endcodeblock %}\n 有了简单工厂我们再看调用者:\n{% codeblock  lang:java %}\n     for (Task task : taskList) {\n             TaskHandlerSimpleFactory.create(task.taskType).handleTask(task.targetId);\n        }\n {% endcodeblock %}\n 怎么样 是不是很清晰了\n## 分析\n现在再来看看我们引入简单工厂之前那个版本的问题是否得到了解决:\n- 分离出具体handler职责,每种任务只处理自己的业务逻辑\n- 分离出工厂职责,专门负责生产任务的handler\n- 分离出调用者职责,最终形成 调用者-工厂-Handler 的调用关系\n- 增加一种任务类型的话只需要增加一个被TaskHandler接口约束的类,实现handleTask方法,并通过简单工厂生产即可 不影响调用者和其他Handler\n有人可能会问了增加任务类型的话不还得修改简单工厂类么,这不违反开放-封闭原则么,Ok 我们来看工厂方法模式\n## 工厂方法模式\n我们想让简单工厂的职责对修改关闭,那我我们只能将工厂进行更进一步的抽象,才能将变化提取出去(慢慢理解啊).第一步,我们抽象出一个工厂接口:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface HandlerFactory {\n        TaskHandler create();\n    }\n {% endcodeblock %}\n然后让具体的业务工厂去实现这个接口,拿一个举例:\n{% codeblock  lang:java %}\n   package com.crazymonkey;\n    public class SplitTaskHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler create() {\n            return new SplitTaskHandler();\n        }\n    }\n {% endcodeblock %}\n 这时候由于我们抽象了工厂的概念 因此每一个Handler的工厂可以直接生产对应的Handler对象来处理具体的任务,那原来的if判断去哪了,看调用者:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                new ComposeTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                new PushTaskHandlerFactory().create().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n## 分析\n看一下我们刚才的问题解决了没有,这个时候你增加一个审核任务类型怎么办,直接创建一个CheckHandlerFactory 通过这个工厂去生产CheckHandler处理具体的任务,有人说不对啊,你增加一种类型不还得改调用者么,加个if......这不也是违反开闭原则么?大哥,你加需求肯定得加判断啊,但是为什么还会产生工厂这种模式呢,Ok下面是自己理解,不保对啊:其实就是一个词 **类的职责**,我们把关注点放在生产Handler这个职责上:简单工厂的职责就是生产handler,增加任务类型Check就得改工厂,不改行不行呢?不行!因为实现不了生产CheckHandler的功能;同样的关注点我们看工厂模式,生产handler这个职责:需要改东西么?不需要!我只需要新建就好了,其他已有的东西都不需要动.所以在生产handler这个职责角度上我们说工厂模式比简单工厂扩展性更强.调用者是另一个角度的问题,反正生产handler的过程我工厂是极好的,handler也生产出来了,你调用者爱调不调呗.我这个模式解决的是 ***生产***这个角度的问题,调用者的变化并不影响生产的过程,因此我们可以理解他是符合开闭原则的.\n说了一大堆,平时用的最多的还是简单工厂,因为简单.\n## 抽象工厂模式\n这个模式其实用的也比较少,但是既然说工厂了,也不能不提,假想一个应用场景,假设我们需要针对不同的任务类型做日志记录,比如拆条的记录到txt里,打包的记录到mongodb中,推送的不处理,怎么弄呢,有人说直接写到具体handler的handletask方法里不就好了么,对!如有有这种需求的话,大多数情况也是这么干的,为什么呢,因为简单.但是从职责划分的角度上来讲,日志记录我们也可以说属于调用者的职责,具体handler只管处理任务就好,不需要干其他的,对吧.原来我们是一条线,生产taskHandler,这时候我们多了一条线,用来生产logHandler,Ok,我们来看,既然想要生产loghandler 那么就需要抽象出来一个接口:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public interface LogHandler {\n        \n      void  handleLog(String targetId);\n    }\n{% endcodeblock %}\n然后这个logHandler得通过工厂生产出来啊,所以要扩展一下上面的工厂接口,让它也能生产logHandler,\n {% codeblock  lang:java %}\n  package com.crazymonkey;\n\n    public interface HandlerFactory {\n        //生产TaskHandler\n      TaskHandler createTaskHandler();\n      \n        //生产LogHandler\n      LogHandler createLogandler();\n    }\n{% endcodeblock %}\n具体实现,还拿拆条任务举例:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public class SplitHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler createTaskHandler() {\n            return new SplitTaskHandler();\n        }\n\n        @Override\n        public LogHandler createLogandler() {\n            return new SplitLogHandler();\n        }\n    }\n{% endcodeblock %}\nOk,现在我们的工厂有了两条生产线,可以生产taskHandler和logHandler,调用者该怎么做很明显了吧:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                //看这里 一个factory生产了两条线\n                HandlerFactory hf =   new SplitHandlerFactory();\n                hf.createTaskHandler().handleTask(task.targetId);\n                hf.createLogandler().handlerLog(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n{% endcodeblock %}\n## 分析\n其实对于实现上来讲 就是扩展了一下HandlerFactory接口,加了个方法,跟以前没啥区别,但是整个的设计思想实际上是有一个更深的抽象,因此叫抽象工厂(个人理解)\n## 总结\n设计模式第一篇,总结了一个工作中常用的工厂模式,举了一个实际工作中的例子作为参考.模式类图网上有的是,可以随便找一个看看,可以加深理论上的理解,其实所有的设计模式思想都是相通的,高内聚,低耦合,面相接口编程,单一职责.用到工厂的情况还有很多种,比如处理不同的数据,翻译不同的参数关键一点就是抽象出要生产的Product,其他的问题就套模式就好了.OK,这篇文章就这样,有问题加我微信.","categories":["设计模式"]},{"title":"设计模式--单例","url":"/2019/04/11/设计模式-单例/","content":"## 应用场景\n顾名思义,单例就是某个类在JVM里只有一个实例对象.为什么会产生单例这种设计模式呢,个人理解,从两方面来解释,一方面是性能:假设某个类的实例非常重量,每次实例化耗时耗资源,那么我们考虑将这个实例在堆中只维护一份,比如我们的系统常常有读取配置文件的需求,那么我们完全可以只读一次就把配置文件中的内容加载进JVM以对象的形式维护,处于性能考虑,没必要每次都是实例化;另一方面是逻辑,比如数据库连接池,或者XXXManager这些管理类型的类,一个系统中有一个就够了,就好比一个房子有一个大管家就可以了,两个就容易打架,处于这种逻辑考虑,可以运用单例的设计模式来处理.\n## 举例\n就拿上面的读取配置文件的例子来学习一下单例模式,假设我们有一个系统,需要和微信对接,获取用户的微信头像,那么我们肯定得知道微信的服务地址吧,写死在程序里这种硬编码的方式可维护性比较差,所以我们可以考虑把微信的接口地址配到配置文件中,然后通过代码把配置读进来,实例化一个配置类:\n配置文件config.properties:\n {% codeblock lang:js %}\n \t#微信接口地址\n \twechatUrl = https://xxx/xxx/xxx\n \t#除了url有可能会有一些其他的配置用来进行参数签名之类的\n \twechatKey = xxxxxx\n \twechatSecret = xxxxxx\n {% endcodeblock %}\n下面我们用一个单例模式来实现上述读取配置文件的过程:\n {% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.util.Properties;\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance;\n\n    public String getWechatUrl() {\n        return wechatUrl;\n    }\n\n    public String getWechatKey() {\n        return wechatKey;\n    }\n\n    public String getWechatSecret() {\n        return wechatSecret;\n    }\n\n    //暴露一个public类型的get方法用来获取实例信息\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n\n    private ConfigConstants() throws Exception {\n        Properties properties = new Properties();\n        properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n        this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n        this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n        this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n    }\n\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n 看一眼运行的结果:\n <img src=\"设计模式-单例/singletonresult.png\">\n 我们可以发现两次取得的是同一个实例,针对上面的例子我们可以总结单例的创建过程:\n 1. **私有的构造方法**:防止该类在别处被实例化:\n 2. **本类中定义一个static对象**:有人会问,为什么是static类型?个人理解:不考虑反射或者反序列化等特殊创建对象的方式(后面会提),我们只考虑常规的访问成员变量的方式有两种:第一种是通过new关键字创建一个对象,然后访问对象中的属性;另一种方式是直接通过类名来访问该类的静态变量,构造方法私有化之后我们无法在外部通过对象实例的方式访问该对象的成员属性,那么我们只能通过类名.方法名的方式来访问,所以就要求方法是static的,static的方法又不能直接拿非static的引用,因此必须要求成员变量instance是static的.\n 3. **提供可访问该对象的公有方法**;\n## 单例的写法\n单例的实现有很多种方式,在这里我们只讨论**能在项目中应用的**实现方式,比如上面那个例子在多线程环境中是无法使用的,两个线程同时进入getInstance的if判断,那么就会产生两个实例.\n### 懒汉模式(同步方法)\n 上面我们举的例子实际上是一种懒汉的模式,之所以称之为懒汉,是因为可以做到懒加载,在使用对象实例的时候才加载,而不是在类加载的时候就加载,既然上面的例子非线程安全,那么最简单的,我们在方法上加个锁让两个线程互斥访问就可以了:\n {% codeblock lang:java %}\n\tpublic static synchronized ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\n上面这种锁方法的做法效率不高(其实只有第一次实例化的时候需要加锁,以后直接取就可以了,但是将整个方法进行同步就意味着每次获取实例都需要互斥访问),所以常用的是一种双重检查的方式:\n### 懒汉模式(Double-Check)\n {% codeblock lang:java %}\n \tprivate volatile static ConfigConstants instance;\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                synchronized (ConfigConstants.class) {\n                    if (instance == null) {\n                        instance = new ConfigConstants();\n                    }\n                }\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\nAB两个线程同时进入if判断,假设A获得锁之后进入第二个if判断,这时候发现instance为空,遂创建一个instance实例,当A获得锁的时候B只能等待锁,当A完成了实例化的过程,释放了锁,此时B获得锁,经过if判断,发现已经有实例了,所以就不会再创建实例,实际上这种方式和同步方法相比是更细粒度的串行化.\n和普通的懒汉模式相比还有一点小差别,就是我们的实例变量采用了volatile修饰,这是为了避免**DCL失效**的问题,简单解释一下:\nJVM的内存模型是主存和线程内存,每个线程在工作的时候先从主存copy一份数据到自己的工作内存,实例化的过程实际就是分配空间,构造对象,将引用指向对象,搞完了再把这个对象的引用刷到主存中去,然后另一个线程就能看到了.逻辑没问题,但实现上会复杂一些,java编译器的指令优化加上底层cpu的并行调整,有可能造成一分配空间线程A就搞个指针指上去了,先指上去再构造对象,然后对象构造一半,又把instance引用刷到主存中去了,这时候底层cpu时间片切换,线程B拿到了时间片进入if条件,发现主存中的instance非空了,所以直接返回实例,这时候拿到的是堆中的一个半成品对象,在操作这个对象的时候就会出问题.整个现象就叫DCL失效,为了解决这个问题我们将引用声明成volatile,那么线程A对instance的操作可以实时对线程B可见.如果想深入了解,可以看一下java的内存模型,和多线程相关的东西.\n### 饿汉模式\n饿汉模式和懒汉模式对比来说,就是类在初始化的时候就加载其中的对象,这时JVM的类加载机制保证了单线程的操作,因此我们不用加任何锁就可以保证线程安全,饿汉模式可以利用静态变量或者静态代码块来实现:\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.io.IOException;\nimport java.util.Properties;\n\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance = new ConfigConstants();\n\n//注释的部分采用static代码块加载,和上面的采用静态变量的方式效果一样\n//    private static ConfigConstants instance;\n//\n//    static{\n//        instance = new ConfigConstants();\n//    }\n    public static ConfigConstants getInstance() {\n       return instance;\n    }\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    private ConfigConstants()  {\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n### 内部类\n只列出关键代码,构造方法之类的可以看上面\n{% codeblock lang:java %}\n    //定义静态内部类\n    private static class ConfigConstantsHolder{\n        private static final ConfigConstants instance = new ConfigConstants();\n\n    }\n\n    public static ConfigConstants getInstance() {\n        return ConfigConstantsHolder.instance;\n    }\n {% endcodeblock %}\n静态内部类和饿汉模式一样,也是利用了虚拟机的类加载机制来保证单例的,但是和饿汉模式不同,在外部类ConfigConstants加载的时候并不会加载内部类,而是在调用getInstance的时候去取ConfigConstantsHolder的成员变量的时候才被初始化,此时instance实例才真正被创建出来,因此我们也可以认为是懒加载的一种.\n### 枚举类\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic enum ConfigEnum {\n    INSTANCE;\n\n    private String wechatUrl=\"\";\n    private String wechatKey=\"\";\n    private String wechatSecret = \"\";\n\n    ConfigEnum(){\n\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public String toString() {\n        return \"ConfigEnum{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    public static void main(String[] args) {\n        System.out.println( ConfigEnum.INSTANCE== ConfigEnum.INSTANCE);\n        System.out.println(ConfigEnum.INSTANCE);\n    }\n}\n{% endcodeblock %}\n枚举类本身就是单例,我们可以利用这个特性实现我们单例的应用场景.\n## 单例的破坏\n我们上面讨论的单例的构造过程中有很重要的一点,就是构造方法私有,那么我们把构造方法藏起来了,别人就会老老实实调用我们的getInstance方法么,毕竟除了new java还提供了其他的生成对象的方式,比如下面这两种:\n### 反射\n{% codeblock lang:java %}\n   public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        Constructor[] constructors = ConfigConstants.class.getDeclaredConstructors();\n        if(constructors.length>0){\n            try {\n                System.out.println(constructors[0]);\n                ConfigConstants c2 = (ConfigConstants)(constructors[0].newInstance(null));\n                System.out.println(c1.equals(c2));\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n{% endcodeblock %}\n看一眼结果,通过单例生成的对象和我们通过getInstance方法生成的对象不是一个:\n<img src =\"设计模式-单例/breaksingleton.png\">\n解决方法就是增加标志位,第一次创建的时候将标志位置true,在构造方法中进行判断,代码不贴了,可以按这种思路自己实现\n### 反序列化\n\n{% codeblock lang:java %}\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"/Users/yangsimeng/Documents/test/test.obj\"));\n            oos.writeObject(ConfigConstants.getInstance());\n            //Read Obj from file\n            File file=new File(\"/Users/yangsimeng/Documents/test/test.obj\");\n            ObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n            ConfigConstants newInstance=(ConfigConstants)ois.readObject();\n            //判断是否是同一个对象\n            System.out.println(newInstance==ConfigConstants.getInstance());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n    }\n{% endcodeblock %}\n如果单例类实现了serializble接口,那么是可以被序列化的,如果序列化之后再反序列化,那么将会生成不同的对象,解决方式就是不让他序列化或者定义readResolve方法返回指定的对象即可:\n{% codeblock lang:java %}\n    private Object readResolve(){\n        return instance;\n    }\n{% endcodeblock %}\n\n","categories":["设计模式"]},{"title":"Mysql索引原理--树形结构的应用","url":"/2019/04/10/Mysql索引原理-树形结构的应用/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--B树和B+树","url":"/2019/04/10/Mysql索引原理-B树和B-树/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--树结构的基本概念","url":"/2019/04/10/Mysql索引原理-树结构的基本概念/","content":"### 写在前面\n&emsp;&emsp;这个系列的文章主要目的就是了解Mysql常用的InnoDB存储引擎的Btree类型索引的内部实现原理.在这之前先了解一下什么是树形结构吧,循序渐近别着急.\n&emsp;&emsp;树形结构实际上就是众多数据结构中的一种,什么是数据结构呢,就是组织数据的方式,什么是数据的组织方式呢?现代社会,我们生活被各种数据包围,知乎看到的文章,游戏刷出来的装备,去超市看到的薯片的配料表,杨二狗涨了300块钱工资...数据的使命就是被消费,说白了就是存储和查找.怎么存的更省地方,怎么找的更快,数据怎么尽可能快速有效的被消费.有一帮人绞尽脑汁的想出了各种各样的数据组织方式,对现实世界的应用场景进行抽象,各种数据结构就产生了,树型结构就是其中的一种,是对一种非线形关系的抽象.\n\n### 基本概念\n<div style='text-align:center'>\n\t<img width=300 src=\"Mysql索引原理--树结构的基本概念/simpletree.png\" >\n</div>\n- 根节点:A就是树的根节点 一棵树的根节点数目可以是0(空树)或1\n- 父节点/父亲节点/双亲节点:当前节点的上一级节点 B就是C的父节点 A是B的父节点\n- 子节点/孩子节点:和父节点相对应 C\n- 兄弟节点:\n- 祖先:\n- 子孙:\n- 度:\n- 层:\n- 高度:\n- 森林\n\n### 树的种类及特性\n\n\n### 树的存储表示\n<!--\n{% codeblock [测试代码] [lang:java]  %}\n\tpublic class Test(){\n\t\tpublic static void main(String [] args){\n\n\n\t}\n\n\n\t}\n\n\t\n{% endcodeblock %}\n-->\n\n\n\n\n\n<!-- <img width=200 src=\"Mysql索引原理--树结构的基本概念/1553657360617.jpg\" >  -->\n\n","tags":["MySQL","数据库索引"],"categories":["MySQL"]}]