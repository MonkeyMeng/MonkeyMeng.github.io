[{"title":"设计模式-理论基础","url":"/2019/04/11/设计模式-理论基础/","content":"\n&emsp;&emsp;各种设计模式实际上就是一种前人总结的代码设计的经验之谈,是一种编程的思维方式.运用他们可以帮我们写出简洁可扩展性强的代码.  \n&emsp;&emsp;网上的设计模式的文章大多都是举一两个简单的例子进行解释,但是不可否认 有的时候demo和实际应用场景还有一些距离,虽然明白了原理,但是真到了实际写代码的过程中不知道怎么用.遇到了冗余代码想优化也无从下手.这个设计模式的专题目的就是尽量结合实际项目的应用场景,对常用的设计模式进行举例说明,使得使用者对于各种常用设计模式有着更直观的认识.  \n下面是一些设计原则和方法论,刚开始可能理解的不深,但是熟悉了几个常用的设计模式之后,回头看这些抽象的总结就会发现,所有的设计模式都是这些方法论的具体实践,我们不讲理论,我们只是理论的搬运工:\n- 单一职责原则  \n- 开放封闭原则\n- 里氏替换原则\n- 依赖倒置原则\n- 接口隔离原则\n- 迪米特法则  \n详细的理论解释请参考:<https://www.cnblogs.com/dolphin0520/p/3919839.html>\n\n\n","categories":["设计模式"]},{"title":"设计模式-工厂","url":"/2019/04/11/设计模式-工厂/","content":"## 应用场景\n&emsp;&emsp;工厂是干嘛的,生产东西的呗,生产东西干什么,用呗.这个逻辑平移到编码领域,更确切的说OO编码,工厂是用来干嘛的,生产对象的,生产对象干什么,实现特定的功能,为什么对象不直接New要通过工厂生产--Ok,举个例子看一下.\n&emsp;&emsp;你看到一个视频微博“2019年常规赛詹姆斯精彩镜头”,你知道怎么来的么?实际上背后有一个视频剪辑平台,视频编辑把一个个的镜头挑出来->剪成一个个小段->拼接->给视频起名字->推送到新浪微博.这些过程抽象一下实际上就是一个个的任务,比如我们设计一个任务表来存这些任务 任务类型分别叫 SPLIT(剪辑)->COMPOSE(拼接)->RENAME(起名字)->PUSH(推送) 编辑们干活的时候数据库产生很多条任务记录需要处理 这些任务分属于不同任务类型 这时候来吧 写代码处理一下这些任务吧\n## 处理\n刚上来可能这么处理,下面这个taskList模拟从数据库取出来的任务列表:\n\n {% codeblock lang:java %}\n\tpackage com.crazymonkey;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\tpublic class TestPattern {\n    //模拟任务类\n    class Task {\n        //任务类型\n        String taskType;\n        //视频Id\n        String targetId;\n        Task(String taskType, String targetId) {\n            this.taskType = taskType;\n            this.targetId = targetId;\n        }\n    }\n    public static void main(String[] args) {\n        //*********准备数据开始********\n        List<Task> taskList = new ArrayList<>();\n        TestPattern tp = new TestPattern();\n        taskList.add(tp.new Task(\"SPLIT\", \"111\"));\n        taskList.add(tp.new Task(\"COMPOSE\", \"222\"));\n        taskList.add(tp.new Task(\"RENAME\", \"111\"));\n        taskList.add(tp.new Task(\"TEST\", \"111\"));\n        taskList.add(tp.new Task(\"PUSH\", \"222\"));\n        taskList.add(tp.new Task(\"PUSH\", \"333\"));\n        //********准备数据结束 下面是核心代码*********\n        for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理拆条任务-->\" + task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理合成任务-->\" + task.targetId);\n            } else if (\"RENAME\".[[equalsIgnoreCase]](task.taskType)) {\n                System.out.println(\"处理起名任务-->\" + task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理推送任务-->\" + task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n    }\n\t}\n {% endcodeblock %}\n## 分析\n我们反过来从基础篇的设计原则看一下 这样写为什么不好:  \n1.这个方法处理了所有逻辑,对象职责不清晰,调用者和功能提供者之间职责不清晰\n2.如果这时候业务需求改了增加一个审核的任务类型怎么办,就得改现有代码增加if判断\n3.具体实现逻辑我只输出了一行,但真实的业务场景的复杂逻辑针对每一种任务都得有很多代码来处理,加一起得写多少代码,一旦重命名任务报错想排查的话怎么搞,想死的心都有了吧  \n## 改进\n&emsp;&emsp;在代码优化的过程中最基础有效的首先就是***单一职责***,对象的单一职责和方法的单一职责,第一步先保证一个对象只干一件事:\n {% codeblock  lang:java %}\n    for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandler().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n               new ComposeTaskHandler().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandler().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n              new PushTaskHandler().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n &emsp;&emsp;可以看到我针对每种任务类型分别创建一个对象,并且提供一个handleTask方法来进行处理各自的业务逻辑,随便取一个出来看看,不一一列举了:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler {\n            public void handleTask(String targetId){\n                System.out.println(\"处理拆条任务-->\" + targetId);\n                //真实的处理逻辑 可能有很多行    \n            }\n    }\n  {% endcodeblock %}\n## 分析\n我们解决了一部分问题,分离了一些职责出去,这时候如果拆条任务处理出错了,我们也很好定位了,直接去对应的类里面找代码就可以了,但是还有一些问题待解决:第一,调用者(Main)直接持有每个任务处理类的对象,这是一种强耦合的关系引用;第二,调用者的职责是调用,现在仍然承担了判断该用哪个Handler的职责;第三,每个Handler都有相同的行为,就是处理任务,我们可以对他们进行更抽象的约束.为了解决这三点问题,我们先来看下简单工厂模式:\n## 简单工厂模式\n首先 声明一个接口 用来抽象我们上面创建的handler,定义handlerTask方法来处理任务:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface TaskHandler {\n        \n       void handleTask(String targetId);\n    }\n {% endcodeblock %}\n 每个任务的实现类实现该接口,还是拿一个举例:\n   {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler implements TaskHandler {\n        @Override\n        public void handleTask(String targetId){\n            System.out.println(\"处理拆条任务-->\" + targetId);\n            //真实的处理逻辑 可能有很多行\n        }\n    }\n {% endcodeblock %}\n\n然后我们创建一个工厂,用来产生TashHandler,工厂的作用就是分离调用者原本的创建Handler的职责,返回值是TaskHandler,这是一个典型的***面相接口编程***的应用运行时才决定示例化哪个对象 这也就是Java三大特性之一的多态 扯远了看工厂:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class TaskHandlerSimpleFactory {\n        //注意返回值是一个接口类型 \n       static TaskHandler create(String taskType){\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n               return new SplitTaskHandler();\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) { \n                return new ComposeTaskHandler(); \n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n              return new RenameTaskHandler();\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n               return new PushTaskHandler();\n            } else {\n                return null;\n            }\n        }\n    }\n {% endcodeblock %}\n 有了简单工厂我们再看调用者:\n{% codeblock  lang:java %}\n     for (Task task : taskList) {\n             TaskHandlerSimpleFactory.create(task.taskType).handleTask(task.targetId);\n        }\n {% endcodeblock %}\n 怎么样 是不是很清晰了\n## 分析\n现在再来看看我们引入简单工厂之前那个版本的问题是否得到了解决:\n- 分离出具体handler职责,每种任务只处理自己的业务逻辑\n- 分离出工厂职责,专门负责生产任务的handler\n- 分离出调用者职责,最终形成 调用者-工厂-Handler 的调用关系\n- 增加一种任务类型的话只需要增加一个被TaskHandler接口约束的类,实现handleTask方法,并通过简单工厂生产即可 不影响调用者和其他Handler\n有人可能会问了增加任务类型的话不还得修改简单工厂类么,这不违反开放-封闭原则么,Ok 我们来看工厂方法模式\n## 工厂方法模式\n我们想让简单工厂的职责对修改关闭,那我我们只能将工厂进行更进一步的抽象,才能将变化提取出去(慢慢理解啊).第一步,我们抽象出一个工厂接口:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface HandlerFactory {\n        TaskHandler create();\n    }\n {% endcodeblock %}\n然后让具体的业务工厂去实现这个接口,拿一个举例:\n{% codeblock  lang:java %}\n   package com.crazymonkey;\n    public class SplitTaskHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler create() {\n            return new SplitTaskHandler();\n        }\n    }\n {% endcodeblock %}\n 这时候由于我们抽象了工厂的概念 因此每一个Handler的工厂可以直接生产对应的Handler对象来处理具体的任务,那原来的if判断去哪了,看调用者:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                new ComposeTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                new PushTaskHandlerFactory().create().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n## 分析\n看一下我们刚才的问题解决了没有,这个时候你增加一个审核任务类型怎么办,直接创建一个CheckHandlerFactory 通过这个工厂去生产CheckHandler处理具体的任务,有人说不对啊,你增加一种类型不还得改调用者么,加个if......这不也是违反开闭原则么?大哥,你加需求肯定得加判断啊,但是为什么还会产生工厂这种模式呢,Ok下面是自己理解,不保对啊:其实就是一个词 **类的职责**,我们把关注点放在生产Handler这个职责上:简单工厂的职责就是生产handler,增加任务类型Check就得改工厂,不改行不行呢?不行!因为实现不了生产CheckHandler的功能;同样的关注点我们看工厂模式,生产handler这个职责:需要改东西么?不需要!我只需要新建就好了,其他已有的东西都不需要动.所以在生产handler这个职责角度上我们说工厂模式比简单工厂扩展性更强.调用者是另一个角度的问题,反正生产handler的过程我工厂是极好的,handler也生产出来了,你调用者爱调不调呗.我这个模式解决的是 ***生产***这个角度的问题,调用者的变化并不影响生产的过程,因此我们可以理解他是符合开闭原则的.\n说了一大堆,平时用的最多的还是简单工厂,因为简单.\n## 抽象工厂模式\n这个模式其实用的也比较少,但是既然说工厂了,也不能不提,假想一个应用场景,假设我们需要针对不同的任务类型做日志记录,比如拆条的记录到txt里,打包的记录到mongodb中,推送的不处理,怎么弄呢,有人说直接写到具体handler的handletask方法里不就好了么,对!如有有这种需求的话,大多数情况也是这么干的,为什么呢,因为简单.但是从职责划分的角度上来讲,日志记录我们也可以说属于调用者的职责,具体handler只管处理任务就好,不需要干其他的,对吧.原来我们是一条线,生产taskHandler,这时候我们多了一条线,用来生产logHandler,Ok,我们来看,既然想要生产loghandler 那么就需要抽象出来一个接口:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public interface LogHandler {\n        \n      void  handleLog(String targetId);\n    }\n{% endcodeblock %}\n然后这个logHandler得通过工厂生产出来啊,所以要扩展一下上面的工厂接口,让它也能生产logHandler,\n {% codeblock  lang:java %}\n  package com.crazymonkey;\n\n    public interface HandlerFactory {\n        //生产TaskHandler\n      TaskHandler createTaskHandler();\n      \n        //生产LogHandler\n      LogHandler createLogandler();\n    }\n{% endcodeblock %}\n具体实现,还拿拆条任务举例:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public class SplitHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler createTaskHandler() {\n            return new SplitTaskHandler();\n        }\n\n        @Override\n        public LogHandler createLogandler() {\n            return new SplitLogHandler();\n        }\n    }\n{% endcodeblock %}\nOk,现在我们的工厂有了两条生产线,可以生产taskHandler和logHandler,调用者该怎么做很明显了吧:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                //看这里 一个factory生产了两条线\n                HandlerFactory hf =   new SplitHandlerFactory();\n                hf.createTaskHandler().handleTask(task.targetId);\n                hf.createLogandler().handlerLog(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n{% endcodeblock %}\n## 分析\n其实对于实现上来讲 就是扩展了一下HandlerFactory接口,加了个方法,跟以前没啥区别,但是整个的设计思想实际上是有一个更深的抽象,因此叫抽象工厂(个人理解)\n## 总结\n设计模式第一篇,总结了一个工作中常用的工厂模式,举了一个实际工作中的例子作为参考.模式类图网上有的是,可以随便找一个看看,可以加深理论上的理解,其实所有的设计模式思想都是相通的,高内聚,低耦合,面相接口编程,单一职责.用到工厂的情况还有很多种,比如处理不同的数据,翻译不同的参数关键一点就是抽象出要生产的Product,其他的问题就套模式就好了.OK,这篇文章就这样,有问题加我微信.","categories":["设计模式"]},{"title":"设计模式--建造者","url":"/2019/04/11/设计模式-建造者/"},{"title":"设计模式--单例","url":"/2019/04/11/设计模式-单例/","content":"## 应用场景\n顾名思义,单例就是某个类在JVM里只有一个实例对象.为什么会产生单例这种设计模式呢,个人理解,从两方面来解释,一方面是性能:假设某个类的实例非常重量,每次实例化耗时耗资源,那么我们考虑将这个实例在堆中只维护一份,比如我们的系统常常有读取配置文件的需求,那么我们完全可以只读一次就把配置文件中的内容加载进JVM以对象的形式维护,处于性能考虑,没必要每次都是实例化;另一方面是逻辑,比如数据库连接池,或者XXXManager这些管理类型的类,一个系统中有一个就够了,就好比一个房子有一个大管家就可以了,两个就容易打架,处于这种逻辑考虑,可以运用单例的设计模式来处理.\n## 举例\n就拿上面的读取配置文件的例子来学习一下单例模式,假设我们有一个系统,需要和微信对接,获取用户的微信头像,那么我们肯定得知道微信的服务地址吧,写死在程序里这种硬编码的方式可维护性比较差,所以我们可以考虑把微信的接口地址配到配置文件中,然后通过代码把配置读进来,实例化一个配置类:\n配置文件config.properties:\n {% codeblock lang:js %}\n \t#微信接口地址\n \twechatUrl = https://xxx/xxx/xxx\n \t#除了url有可能会有一些其他的配置用来进行参数签名之类的\n \twechatKey = xxxxxx\n \twechatSecret = xxxxxx\n {% endcodeblock %}\n下面我们用一个单例模式来实现上述读取配置文件的过程:\n {% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.util.Properties;\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance;\n\n    public String getWechatUrl() {\n        return wechatUrl;\n    }\n\n    public String getWechatKey() {\n        return wechatKey;\n    }\n\n    public String getWechatSecret() {\n        return wechatSecret;\n    }\n\n    //暴露一个public类型的get方法用来获取实例信息\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n\n    private ConfigConstants() throws Exception {\n        Properties properties = new Properties();\n        properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n        this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n        this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n        this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n    }\n\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n 看一眼运行的结果:\n <img src=\"设计模式-单例/singletonresult.png\">\n 我们可以发现两次取得的是同一个实例,针对上面的例子我们可以总结单例的创建过程:\n 1. **私有的构造方法**:防止该类在别处被实例化:\n 2. **本类中定义一个static对象**:有人会问,为什么是static类型?个人理解:不考虑反射或者反序列化等特殊创建对象的方式(后面会提),我们只考虑常规的访问成员变量的方式有两种:第一种是通过new关键字创建一个对象,然后访问对象中的属性;另一种方式是直接通过类名来访问该类的静态变量,构造方法私有化之后我们无法在外部通过对象实例的方式访问该对象的成员属性,那么我们只能通过类名.方法名的方式来访问,所以就要求方法是static的,static的方法又不能直接拿非static的引用,因此必须要求成员变量instance是static的.\n 3. **提供可访问该对象的公有方法**;\n## 单例的写法\n单例的实现有很多种方式,在这里我们只讨论**能在项目中应用的**实现方式,比如上面那个例子在多线程环境中是无法使用的,两个线程同时进入getInstance的if判断,那么就会产生两个实例.\n### 懒汉模式(同步方法)\n 上面我们举的例子实际上是一种懒汉的模式,之所以称之为懒汉,是因为可以做到懒加载,在使用对象实例的时候才加载,而不是在类加载的时候就加载,既然上面的例子非线程安全,那么最简单的,我们在方法上加个锁让两个线程互斥访问就可以了:\n {% codeblock lang:java %}\n\tpublic static synchronized ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\n上面这种锁方法的做法效率不高(其实只有第一次实例化的时候需要加锁,以后直接取就可以了,但是将整个方法进行同步就意味着每次获取实例都需要互斥访问),所以常用的是一种双重检查的方式:\n### 懒汉模式(Double-Check)\n {% codeblock lang:java %}\n \tprivate volatile static ConfigConstants instance;\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                synchronized (ConfigConstants.class) {\n                    if (instance == null) {\n                        instance = new ConfigConstants();\n                    }\n                }\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\nAB两个线程同时进入if判断,假设A获得锁之后进入第二个if判断,这时候发现instance为空,遂创建一个instance实例,当A获得锁的时候B只能等待锁,当A完成了实例化的过程,释放了锁,此时B获得锁,经过if判断,发现已经有实例了,所以就不会再创建实例,实际上这种方式和同步方法相比是更细粒度的串行化.\n和普通的懒汉模式相比还有一点小差别,就是我们的实例变量采用了volatile修饰,这是为了避免**DCL失效**的问题,简单解释一下:\nJVM的内存模型是主存和线程内存,每个线程在工作的时候先从主存copy一份数据到自己的工作内存,实例化的过程实际就是分配空间,构造对象,将引用指向对象,搞完了再把这个对象的引用刷到主存中去,然后另一个线程就能看到了.逻辑没问题,但实现上会复杂一些,java编译器的指令优化加上底层cpu的并行调整,有可能造成一分配空间线程A就搞个指针指上去了,先指上去再构造对象,然后对象构造一半,又把instance引用刷到主存中去了,这时候底层cpu时间片切换,线程B拿到了时间片进入if条件,发现主存中的instance非空了,所以直接返回实例,这时候拿到的是堆中的一个半成品对象,在操作这个对象的时候就会出问题.整个现象就叫DCL失效,为了解决这个问题我们将引用声明成volatile,那么线程A对instance的操作可以实时对线程B可见.如果想深入了解,可以看一下java的内存模型,和多线程相关的东西.\n### 饿汉模式\n饿汉模式和懒汉模式对比来说,就是类在初始化的时候就加载其中的对象,这时JVM的类加载机制保证了单线程的操作,因此我们不用加任何锁就可以保证线程安全,饿汉模式可以利用静态变量或者静态代码块来实现:\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.io.IOException;\nimport java.util.Properties;\n\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance = new ConfigConstants();\n\n//注释的部分采用static代码块加载,和上面的采用静态变量的方式效果一样\n//    private static ConfigConstants instance;\n//\n//    static{\n//        instance = new ConfigConstants();\n//    }\n    public static ConfigConstants getInstance() {\n       return instance;\n    }\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    private ConfigConstants()  {\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n### 内部类\n只列出关键代码,构造方法之类的可以看上面\n{% codeblock lang:java %}\n    //定义静态内部类\n    private static class ConfigConstantsHolder{\n        private static final ConfigConstants instance = new ConfigConstants();\n\n    }\n\n    public static ConfigConstants getInstance() {\n        return ConfigConstantsHolder.instance;\n    }\n {% endcodeblock %}\n静态内部类和饿汉模式一样,也是利用了虚拟机的类加载机制来保证单例的,但是和饿汉模式不同,在外部类ConfigConstants加载的时候并不会加载内部类,而是在调用getInstance的时候去取ConfigConstantsHolder的成员变量的时候才被初始化,此时instance实例才真正被创建出来,因此我们也可以认为是懒加载的一种.\n### 枚举类\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic enum ConfigEnum {\n    INSTANCE;\n\n    private String wechatUrl=\"\";\n    private String wechatKey=\"\";\n    private String wechatSecret = \"\";\n\n    ConfigEnum(){\n\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public String toString() {\n        return \"ConfigEnum{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    public static void main(String[] args) {\n        System.out.println( ConfigEnum.INSTANCE== ConfigEnum.INSTANCE);\n        System.out.println(ConfigEnum.INSTANCE);\n    }\n}\n{% endcodeblock %}\n枚举类本身就是单例,我们可以利用这个特性实现我们单例的应用场景.\n## 单例的破坏\n我们上面讨论的单例的构造过程中有很重要的一点,就是构造方法私有,那么我们把构造方法藏起来了,别人就会老老实实调用我们的getInstance方法么,毕竟除了new java还提供了其他的生成对象的方式,比如下面这两种:\n### 反射\n{% codeblock lang:java %}\n   public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        Constructor[] constructors = ConfigConstants.class.getDeclaredConstructors();\n        if(constructors.length>0){\n            try {\n                System.out.println(constructors[0]);\n                ConfigConstants c2 = (ConfigConstants)(constructors[0].newInstance(null));\n                System.out.println(c1.equals(c2));\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n{% endcodeblock %}\n看一眼结果,通过单例生成的对象和我们通过getInstance方法生成的对象不是一个:\n<img src =\"设计模式-单例/breaksingleton.png\">\n解决方法就是增加标志位,第一次创建的时候将标志位置true,在构造方法中进行判断,代码不贴了,可以按这种思路自己实现\n### 反序列化\n\n{% codeblock lang:java %}\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"/Users/yangsimeng/Documents/test/test.obj\"));\n            oos.writeObject(ConfigConstants.getInstance());\n            //Read Obj from file\n            File file=new File(\"/Users/yangsimeng/Documents/test/test.obj\");\n            ObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n            ConfigConstants newInstance=(ConfigConstants)ois.readObject();\n            //判断是否是同一个对象\n            System.out.println(newInstance==ConfigConstants.getInstance());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n    }\n{% endcodeblock %}\n如果单例类实现了serializble接口,那么是可以被序列化的,如果序列化之后再反序列化,那么将会生成不同的对象,解决方式就是不让他序列化或者定义readResolve方法返回指定的对象即可:\n{% codeblock lang:java %}\n    private Object readResolve(){\n        return instance;\n    }\n{% endcodeblock %}\n\n","categories":["设计模式"]},{"title":"Mysql索引原理--树形结构的应用","url":"/2019/04/10/Mysql索引原理-树形结构的应用/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--B树和B+树","url":"/2019/04/10/Mysql索引原理-B树和B-树/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--树结构的基本概念","url":"/2019/04/10/Mysql索引原理-树结构的基本概念/","content":"### 写在前面\n&emsp;&emsp;这个系列的文章主要目的就是了解Mysql常用的InnoDB存储引擎的Btree类型索引的内部实现原理.在这之前先了解一下什么是树形结构吧,循序渐近别着急.\n&emsp;&emsp;树形结构实际上就是众多数据结构中的一种,什么是数据结构呢,就是组织数据的方式,什么是数据的组织方式呢?现代社会,我们生活被各种数据包围,知乎看到的文章,游戏刷出来的装备,去超市看到的薯片的配料表,杨二狗涨了300块钱工资...数据的使命就是被消费,说白了就是存储和查找.怎么存的更省地方,怎么找的更快,数据怎么尽可能快速有效的被消费.有一帮人绞尽脑汁的想出了各种各样的数据组织方式,对现实世界的应用场景进行抽象,各种数据结构就产生了,树型结构就是其中的一种,是对一种非线形关系的抽象.\n\n### 基本概念\n<div style='text-align:center'>\n\t<img width=300 src=\"Mysql索引原理--树结构的基本概念/simpletree.png\" >\n</div>\n- 根节点:A就是树的根节点 一棵树的根节点数目可以是0(空树)或1\n- 父节点/父亲节点/双亲节点:当前节点的上一级节点 B就是C的父节点 A是B的父节点\n- 子节点/孩子节点:和父节点相对应 C\n- 兄弟节点:\n- 祖先:\n- 子孙:\n- 度:\n- 层:\n- 高度:\n- 森林\n\n### 树的种类及特性\n\n\n### 树的存储表示\n<!--\n{% codeblock [测试代码] [lang:java]  %}\n\tpublic class Test(){\n\t\tpublic static void main(String [] args){\n\n\n\t}\n\n\n\t}\n\n\t\n{% endcodeblock %}\n-->\n\n\n\n\n\n<!-- <img width=200 src=\"Mysql索引原理--树结构的基本概念/1553657360617.jpg\" >  -->\n\n","tags":["MySQL","数据库索引"],"categories":["MySQL"]}]