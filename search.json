[{"title":"设计模式-装饰者","url":"/2019/04/22/设计模式-装饰者/","content":"## 前言\n在面向对象的设计当中,我们认为成员变量是对象的属性,方法是对象的行为,比如我们新建一个Cat类,且实例化一个对象出来,那么颜色/体重/...这些属性我们可以作为成员变量,跑/叫/散步...我们将这些动态行为抽象成方法.如果当前类的设计无法满足需求,我们需要对现有类的行为进行增强,有几种途径:1.直接修改2.继承并重写3.装饰者4.其他 直接修改实际上违反了开闭原则,况且并非所有的时候都可以对源码进行直接修改,继承实际上是获取父类的所有非privage行为,而且java是单继承,这种方式显得不够灵活.装饰者模式实际上就是为了灵活的解决类的行为增强这一类问题.网上博客说的最多的装饰者的应用就是IO流,那么我们就以IO流为例子,解释一下装饰者的应用.\n## 举例\n比如我们将一段文本写入txt文档当中:\n{% codeblock lang:java %}\npackage com.crazymonkey.decorator;\nimport java.io.*;\n\npublic class TestStream {\n    public static void main(String[] args) {\n        String str = \"I am a Stream Decorator Test\";\n        String filePath = \"/Users/yangsimeng/Documents/test/teststream.txt\";\n        try {\n            OutputStream os  = new FileOutputStream(filePath) ;\n            os.write(str.getBytes());\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n {% endcodeblock %}\n 当我的文本比较长的时候,不想每次都往硬盘上写,这时候就可以写一部分到内存缓冲区中,缓冲区满了再统一写入硬盘.这种情况实际上就是对原用功能的增强,这时候我们考虑BufferedInputStream:\n {% codeblock lang:java %}\npackage com.crazymonkey.decorator;\nimport java.io.*;\npublic class TestStream {\n    public static void main(String[] args) {\n        String str = \"I am a Stream Decorator Test\";\n        String filePath = \"/Users/yangsimeng/Documents/test/teststream.txt\";\n        try {\n            OutputStream os  = new BufferedOutputStream(new FileOutputStream(filePath)) ;\n            os.write(str.getBytes());\n            os.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n {% endcodeblock %}\n 这么实现相当于在原有的FileOutputStream上包装了一层,对外表现没有变,还是OutputStream,我们先来看一下这几个类的继承关系:\n <img width=400 src='设计模式-装饰者/streamextend.png'>\n 之所以我们能完成包装,是因为这两个类都有一个同样的父类:OutputStream,有同样的行为:write,那我们来看一下BufferedOutputStream是怎么实现增强的:\n {%codeblock FileOutputStream中的write方法  lang:java %}\n    public void write(int b) throws IOException {\n        write(b, append);\n    }\n\n   private native void write(int b, boolean append) throws IOException;\n {% endcodeblock %}\n FileOutputStream中的write方法最简单,直接调用了一个native方法来实现向硬盘上写数据.\n\n {%codeblock  BufferedOutputStream的write方法 lang:java %}\n \t//构造方法,指定要增强的对象out\n    public BufferedOutputStream(OutputStream out) {\n        this(out, 8192);\n    }\n    //超出缓冲区了,就往硬盘写,否则就往缓冲区加\n   public synchronized void write(int b) throws IOException {\n        if (count >= buf.length) {\n            flushBuffer();\n        }\n        buf[count++] = (byte)b;\n    }\n\n    /** Flush the internal buffer */\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n {% endcodeblock %}\n Ok了,通过上面这个例子很容易看到BufferedOutOutputStream是怎么对write过程进行增强的了.先写入初始化好的缓冲区,缓冲区满了统一写入硬盘.如果我们对BufferedOutputStream提供的功能还不满意,我们也可以对它进行增强啊,最简单的例子,比如我们在写之前和之后都进行日志输出,我们可以创建一个LogBufferedOutputStream:\n{%codeblock  日志增强的输出流类 lang:java %}\npackage com.crazymonkey.decorator;\n\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\npublic class LogBuffedOutputStream extends FilterOutputStream {\n\n    boolean needLog = true;\n\n    public LogBuffedOutputStream(OutputStream out) {\n        super(out);\n    }\n    public LogBuffedOutputStream(OutputStream out,boolean needLog) {\n        super(out);\n        this.needLog=needLog;\n    }\n    public void write(byte [] bytes) throws IOException {\n        if(needLog){\n            System.out.println(\"**********开始写数据******************\");\n        }\n        out.write(bytes);\n        if(needLog){\n            System.out.println(\"**********写完啦******************\");\n        }\n    }\n}\n {% endcodeblock %}\n## 总结\n其实装饰者和责任链在实现上有些类似,责任链是职责划分,装饰者是对原有对象功能的增强,理解精神即可.\n","categories":["设计模式"]},{"title":"设计模式-责任链","url":"/2019/04/18/设计模式-责任链/","content":"## 应用场景\n责任链模式,从名字也可以看出来,责任的链条,突出的两个特点:职责的**分离**与**动态组合**.比如我们请假的审批流,从下到上每个领导都会对请求进行处理(通过或驳回),因为各个领导的职责是分离的,这时候我们在整个链条上进行增加或拆解也会变得很容易.再比如在讲模板方法模式的时候提到的鉴权的应用场景,也可以用责任链来处理.重新看一下场景:假设现在我们要处理一个用户的登录请求,需要对用户进行身份校验->url地址校验->用户权限校验三步,校验成功的才可以访问到业务接口.Ok,现在我们用责任链的思想来实现一下这个应用场景.\n## 实现1\n首先我们需要一个请求类,这个类是我们整个责任链处理的对象:\n {%codeblock 模拟请求类 lang:java %}\npackage com.crazymonkey.chain;\n\n//模拟请求类\npublic class Request {\n\n    private String userId;\n\n    private String requestUrl;\n\n\n    public Request(String userId, String requestUrl) {\n        this.userId = userId;\n        this.requestUrl = requestUrl;\n    }\n\n    public String getUserId() {\n        return userId;\n    }\n\n    public void setUserId(String userId) {\n        this.userId = userId;\n    }\n\n    public String getRequestUrl() {\n        return requestUrl;\n    }\n\n    public void setRequestUrl(String requestUrl) {\n        this.requestUrl = requestUrl;\n    }\n}\n {% endcodeblock %}\n然后将职责的处理类进行抽象:\n {%codeblock  抽象的处理节点 lang:java %}\n\tpackage com.crazymonkey.chain;\n\n\t//鉴权接口的抽象\n\tpublic abstract class AuthHandler {\n\n\t    //持有后继节点的引用\n\t    protected AuthHandler next;\n\n\t    AuthHandler(AuthHandler next){\n\t        this.next=next;\n\t    }\n\t    //鉴权接口\n\t    abstract  boolean isLegal(Request request);\n\n\t}\n {% endcodeblock %}\n责任链上的所有节点都有一致的鉴权行为,只不过每个节点的鉴权方式不一样,**行为一致,方式不同**这也是所有设计模式通用的应用场景.扯远了,来看一下具体的鉴权实现类:\n\n{%codeblock  用户合法性校验节点 lang:java %}\n\tpackage com.crazymonkey.chain;\n\t//校验用户是否合法\n\tpublic class UserLegalHandler extends  AuthHandler{\n\n\t    public UserLegalHandler(AuthHandler next) {\n\t        super(next);\n\t    }\n\n\t    @Override\n\t    boolean isLegal(Request request)  {\n\t        boolean isUserLegal = false;\n\t        System.out.println(\"实现自己的用户鉴权逻辑 \");\n\t        isUserLegal=true;\n\t        return isUserLegal?(this.next==null?isUserLegal:next.isLegal(request)):isUserLegal;\n\t    }\n\t}\n {% endcodeblock %}\n\n {%codeblock  URL合法性校验节点 lang:java %}\n\tpackage com.crazymonkey.chain;\n\n\tpublic class UrlLegalHandler extends AuthHandler {\n\n\t    public UrlLegalHandler(AuthHandler next) {\n\t        super(next);\n\t    }\n\n\t    @Override\n\t    boolean isLegal(Request request) {\n\t        System.out.println(\"Url合法性校验\");\n\t        boolean isUrlLeagal = false;\n\t        return isUrlLeagal?(this.next==null?isUrlLeagal:next.isLegal(request)):isUrlLeagal;\n\t    }\n\t}\n {% endcodeblock %}\n\n{%codeblock  用户权限合法性校验节点 lang:java %}\n\tpackage com.crazymonkey.chain;\n\n\tpublic class UserAuthenticatedHandler extends AuthHandler {\n\n\t    public UserAuthenticatedHandler(AuthHandler next) {\n\t        super(next);\n\t    }\n\t    @Override\n\t    boolean isLegal(Request request) {\n\t        System.out.println(\" 用户权限合法性校验\");\n\t        boolean isLeagal = false;\n\t        return isLeagal ? (this.next == null ? isLeagal : next.isLegal(request)) : isLeagal;\n\t    }\n\t}\n {% endcodeblock %}\n可以看到,我们将鉴权的三个步骤分离到三个类中,三个类拥有共同的行为,并且构造的时候就获得了一个后继的引用,next就像指针一样,指向下一个节点,这样一个个的节点就向链条一样穿起来了,我们看下调用的方式:\n\n{%  codeblock lang:java %}\n\tpackage com.crazymonkey.chain;\n\tpublic class TestChain {\n\t    public static void main(String[] args) {\n\t        boolean isAuth = new UserLegalHandler(new UrlLegalHandler(new UserAuthenticatedHandler(null))).isLegal(new Request(\"111\",\"222\"));\n\t        System.out.println(\"鉴权结果：\"+isAuth);\n\t    }\n\t}\n\n {% endcodeblock %}\n看下结果:\n<img src='设计模式-责任链/chainresult.png'>\n## 分析\n再回到我们文章开头提到的两个关键词**职责分离**,**动态组合**,假如这时候我们想在Url校验节点的后面增加签名校验怎么办呢?创建一个SignatureCheckHandler类继承AuthHandler,实现签名校验逻辑,然后在调用的时候把这个对象加到UrlLegalHandler后面即可,对现有的功能不造成影响.\n## 实现2\n我们现在已经了解了责任链的基本思想和用法,上面那种实现可以解决责任链相对固定的应用场景,因为我们是在代码中手动指定的后继节点.那么我们思考一下,能不能通过配置文件的方式来配置各个节点,并且使责任链的应用场景不局限于鉴权呢?答案当然是可以的,我们来看下实现:\n首先我们定一个责任链类,用来控制整个责任链的职责流转,这个责任链缓存了该链条上的所有节点\n{%codeblock  责任链类  lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Chain {\n    //游标 用来标识当前处于哪个节点\n    private int cursor;\n    //存储所有的节点\n    public List<Handler> handlers=new ArrayList<>();\n\n    public void addHandler(Handler handler){\n        this.handlers.add(handler);\n    }\n\n    public boolean execute(Request request){\n        if(cursor<handlers.size()){\n           return handlers.get(cursor++) .handle(request,this);\n        }else {\n            System.out.println(\"责任链执行完毕。。。\");\n            return true;\n        }\n    }\n}\n {% endcodeblock %}\n\n链条中存储的Handler接口很简单,只有一个handle方法\n{%codeblock Handler抽象 lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\n\n/**\n * 所有责任节点的接口\n */\npublic interface Handler {\n\n    boolean handle(Request request,Chain chain);\n\n}\n {% endcodeblock %}\n\nOK,现在我们可以定义具体的handler了:\n\n{%codeblock 用户合法性校验Handler lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\n\npublic class UserLegalHandler  implements Handler{\n\n    @Override\n    public boolean handle(Request request, Chain chain) {\n\n        System.out.println(\"用户鉴权逻辑\");\n        boolean isLegal = true;\n        if(isLegal){\n            return  chain.execute(request);\n        }else{\n            return false;\n        }\n    }\n}\n{% endcodeblock %}\n\n{%codeblock URL合法性校验Handler lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\n\npublic class UrlLegalHandler implements Handler {\n\n    @Override\n    public boolean handle(Request request, Chain chain) {\n        System.out.println(\"URL合法性校验\");\n        boolean isLegal = true;\n        if(isLegal){\n            return  chain.execute(request);\n        }else{\n            return false;\n        }\n    }\n}\n{% endcodeblock %}\n\n{%codeblock 用户权限合法性校验Handler lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\n\npublic class UserAuthenticatedHandler implements Handler {\n\n    @Override\n    public boolean handle(Request request, Chain chain) {\n        System.out.println(\"用户权限合法性校验\");\n        boolean isLegal = true;\n        if(isLegal){\n            return  chain.execute(request);\n        }else{\n            return false;\n        }\n    }\n}\n{% endcodeblock %}\n\n{%codeblock 调用者 lang:java %}\npackage com.crazymonkey.chain2;\n\nimport com.crazymonkey.chain.Request;\n\npublic class TestChain {\n    public static void main(String[] args) {\n        Chain chain = new Chain();\n        chain.addHandler(new UserLegalHandler());\n        chain.addHandler(new UrlLegalHandler());\n        chain.addHandler(new UserAuthenticatedHandler());\n        System.out.println(\"鉴权结果：\"+chain.execute(new Request(\"111\",\"222\"))); ;\n    }\n}\n{% endcodeblock %}\n## 分析\n运行结果就不贴了.经过上面的过程,和实现1相比,我们已经不需要为具体的handler实现类指定next节点了,从这个角度上讲我们已经实现了责任链的创建和具体的handler的分离,现在如果想要改成配置文件的方式就很简单了吧,我们可以自己定义数据格式,自己解析,通过反射机制来生成对象.嗯?这个模式好像有些眼熟....java web里面的filter就是这么搞的吧,我们在web.xml里定义filter节点,在访问servlet的时候,就可以经过我们定义好的FilterChain进行过滤.我们这个例子就是对filter的实现原理略加改造得到的,有兴趣的同学可以自己看一下filterchain的源码研究一下.\n## 总结\n我们举了两个例子来说明责任链这种设计模式,归根到底,也是为了实现职责分离和松耦合的代码组织方式,实现一里为什么不同的节点可以以next形式串联起来,因为next类型是抽象类,而不是具体类.这还是面向抽象编程实现高可扩展性的一种实践.\n","categories":["设计模式"]},{"title":"设计模式-模板","url":"/2019/04/17/设计模式-模板/","content":"## 例行闲扯\n模板方法模式比较简单,是解释面向抽象编程一个很好的例子,模版方法的应用场景实际上就四个字**流程提取**.比如我们发工资->请老婆吃饭->上交工资,这就是一个很典型的流程.至于你发了多少,吃的什么,上交时候痛苦或快乐,都是实现.对于关注流程的应用场景来讲,我们并不关心实现.\n## 举例\n上面发工资那个例子还挺好的,如果学会了模版模式的话可以试着写一下.我们举一个更通用的例子,比如http接口、在访问数据的时候都需要对登录的人进行权限的校验,大部分是基于session的.我们假定校验分三步:身份校验->接口地址校验->权限校验.ok了,我们在不知不觉中就抽象出了一个鉴权流程,和上面那个工资流程是一样一样的.有的同学说,抽象这个流程有啥用么,我直接写三个方法去调用查数据库不就得了么,OK 单体应用没毛病,但是如果你有多个服务都需要鉴权呢,每个服务又有自己的鉴权方式呢,每一个都写三个方法么?**做抽象,是为了更好的复用**.\n## 上代码\n {% codeblock lang:java %}\npackage com.crazymonkey.template;\n\npublic abstract  class AuthController {\n\n    abstract boolean isUserLegal();\n\n    abstract boolean isUrlLegal();\n\n    abstract boolean isUserAuthenticated();\n\n\n    public void auth(Request request){\n\n        if(isUserLegal()&&isUrlLegal()&&isUserAuthenticated()){\n            System.out.println(\"鉴权成功\");\n        }else{\n            System.out.println(\"鉴权失败\");\n        }\n    }\n\n    //模拟接口过来的请求对象\n    class Request{\n        String userId;\n\n        String sessionId;\n\n        String requestUrl;\n\n    }\n}\n {% endcodeblock %}\n AuthContrller模拟请求处理类,注意:他的三个鉴权方法全部都是抽象的,只提供了一个具体的鉴权入口auth方法,现在代码写好了,领导规定,所有系统全部都要接入这个鉴权模块,走一样的流程,OK 来看个实现:\n{% codeblock A系统接入 lang:java %}\n    package com.crazymonkey.template;\n\n    public class SystemAController extends AuthController {\n        @Override\n        boolean isUserLegal(String userId) {\n            System.out.println(\"查啊查啊查A系统User\");\n            return true;\n        }\n\n        @Override\n        boolean isUrlLegal(String url) {\n            System.out.println(\"查啊查啊查A系统url\");\n            return true;\n        }\n\n        @Override\n        boolean isUserAuthenticated(String userId) {\n            System.out.println(\"A对所有人开放,不需要鉴权，直接返回true\");\n            return true;\n        }\n\n    }\n{% endcodeblock %}\n\n{% codeblock B系统接入 lang:java %}\npackage com.crazymonkey.template;\n\npublic class SystemBController extends AuthController{\n\n    @Override\n    boolean isUserLegal(String userId) {\n        System.out.println(\"查啊查啊查BUser\");\n        return true;\n    }\n\n    @Override\n    boolean isUrlLegal(String url) {\n        System.out.println(\"不进行Url鉴权，直接返回true\");\n        return true;\n    }\n\n    @Override\n    boolean isUserAuthenticated(String userId) {\n        System.out.println(\"查啊查啊查B是不是管理员\");\n        return false;\n    }\n}\n{% endcodeblock %}\n我们写个main方法来模拟一下请求:\n{% codeblock 模拟请求 lang:java %}\npackage com.crazymonkey.template;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        AuthController.Request request =  new AuthController.Request(\"111\",\"/test/info\");\n        System.out.println(\"a------\");\n        new SystemAController().auth(request);\n        System.out.println(\"b------\");\n        new SystemBController().auth(request);\n\n    }\n}\n{% endcodeblock %}\n来看下结果\n<img src=\"设计模式-模板/templateresult.png\">\n很明显吧,针对同一条流程A和B系统分别提供了自己的实现,如果我们是maven工程,那么我们可以把代码放在common底下,提供流程上的约束,让大家都提供实现,面向抽象编程就是好啊,我只提供约束,你们还都得听我的,美滋滋.\n## 扩展\n假如这个时候领导又说了,我们要把访问信息写到日志里记录一下子,但是只有部分系统才需要.当然你可以去改造ABC...各种系统啊,用什么日志框架啊什么的,但是我们想下,日志记录实际上是通用流程的一部分,只不过呢,有的系统不需要,说明此时子流程和父流程已经不是完全贴合的关系了,**子流程如果对父流程产生影响的时候,我们考虑用钩子函数**\n\n{% codeblock 钩子函数 lang:java %}\n    //定义获取日志级别的方法 -1 不打日志  1 打日志\n    protected  int logLevel(){return 1;}\n\n    public void auth(Request request){\n        //注意这里\n        if(this.logLevel()==1){\n            System.out.println(\"我是日志\");\n        }\n        if(isUserLegal(request.userId)&&isUrlLegal(request.requestUrl)&&isUserAuthenticated(request.userId)){\n            System.out.println(\"鉴权成功\");\n        }else{\n            System.out.println(\"鉴权失败\");\n        }\n    }\n{% endcodeblock %}\n只看关键的部分,我们定义了一个logLevel的方法,用来控制日志的输出,默认是输出的,此时如果系统A不想输出日志怎么办呢:很简单,你重写logLevel方法不就得了么,毕竟运行时this指向的是子类对象.看到这我们就明白了,整个模版方法的核心,又回到了最初的概念,父类引用指向子类对象是什么呢?多态!\n哦,解释一下钩子,个人理解,这里的钩子就跟后门差不多,如果子流程想对父流程实现修改,那么就可以通过父流程留的这个后门操作.比如本例,loglevel就是子类钩住父类的一个钩子,带绳的那种,钩上之后可以顺着绳子爬到父类上搞点事情.\n","categories":["设计模式"]},{"title":"设计模式--建造者","url":"/2019/04/15/设计模式-建造者/","content":"## 应用场景\n建造者,是构建对象的时候用的一种设计模式,有的人说,构建对象直接new就可以了,怎么还有设计模式呢.如果一个类的结构比较简单,那么我们可以直接new创建对象,但是如果考虑一些构造方法的变化和业务的扩展,就会体现出建造者模式的优点.\n## 举例1\n我们在工作中肯定会遇到分页查询的场景,由于返回的数据结构固定,因此我们可以定义一个分页类来进行封装:\n{% codeblock lang:java %}\npackage com.crazymonkey.builder;\n\nimport java.util.List;\npublic class Pagination<T> {\n\n    //当前页\n    private int currentPage;\n    //每页条数\n    private int pageSize;\n    //总条数\n    private int totalLines;\n    //总页数\n    private int totalPages;\n    //数据信息\n    List<T> data;\n\n    //忽略getters and setters\n}\n {% endcodeblock %}\n\n我们在使用分页的时候就直接构造呗\n{% codeblock lang:java %}\n \t//内部类,用来模拟从数据库中查出来的实体\n  private class User{\n        private String userId;\n        private String userName;\n\n    }\n    public static void main(String[] args) {\n    \t//分页的使用 重点关注下这里\n        List<Pagination.User> users = new ArrayList<>();\n        Pagination page = new Pagination<>();\n        page.setCurrentPage(0);\n        page.setPageSize(10);\n        page.setTotalLines(100);\n        page.setTotalPages(10);\n        page.setData(new ArrayList<Pagination.User>());\n    }\n {% endcodeblock %}\n## 分析\n我们还是从设计原则来分析一下,main方法作为调用者来讲,他的目的就是为了获取一个pagination对象,在这个过程中他其实不需要关注对象的**构造细节**,什么是构造细节,就是对象包含什么属性,到底是怎么赋值的.有人说,那好办啊,java的三大特性之首,封装,我们把实现细节封起来不就得了么,怎么封呢---最简单的方式:构造方法呗,\n{% codeblock lang:java %}\n\t//构造方法\n  Pagination(int currentPage,int pageSize,int totalLines,int totalPages,List<T> data){\n        this.currentPage = currentPage;\n        this.pageSize = pageSize;\n        this.totalLines = totalLines;\n        this.totalPages = totalPages;\n        this.data = data;\n    }\n    //具体调用\n    public static void main(String[] args) {\n        List<Pagination.User> users = new ArrayList<>();\n        Pagination page = new Pagination<>(0,10,100,10,new ArrayList<Pagination.User>());\n    }\n{% endcodeblock %}\n调用的地方变成了一行,美滋滋,但是突然有个需求,返回的分页实体中要扩展一个type字段,用来标示前端要用哪种展示方式(不讨论需求合理性,只进行简单扩展)我们就需要修改构造方法,或者重载构造方法.每次需求变更都要重新修改构造方法,并修改调用者的代码,如果参数很多的情况下构造函数也会显得杂乱且不好维护\n## 应用\n所以我们考虑引入建造者类来帮我们处理构造过程:\n{% codeblock lang:java %}\n\t//引入静态内部类(如果定义成外部类也一样,体会思想即可)\n    private static class Builder{\n\n        private Pagination pagination;\n\n        public Builder(Pagination p){this.pagination = p;}\n        public Builder buildCurrentPage(int currentPage){\n            this.pagination.currentPage=currentPage;\n            return this;\n        }\n        public Builder buildPageSize(int pageSize){\n            this.pagination.pageSize=pageSize;\n            return this;\n        }\n        public Builder buildTotalLines(int totalLines){\n            this.pagination.totalLines=totalLines;\n            return this;\n        }\n        public Builder buildTotalPages(int totalPages){\n            this.pagination.totalPages=totalPages;\n            return this;\n        }\n        public Builder buildData(List data){\n            this.pagination.data=data;\n            return this;\n        }\n        public Pagination build(){\n            return this.pagination;\n        }\n    }\n    //具体调用\n    public static void main(String[] args) {\n        Pagination page = new Pagination.Builder(new Pagination()).buildCurrentPage(0).buildPageSize(10).buildTotalLines(100).build();\n    }\n{% endcodeblock %}\n## 分析\n从上面的调用过程我们可以看到,如果此时增加需求,并不需要重载构造方法,只需要修改建造者类就可以了.这样修改的话有两点好处,一是逻辑比较清晰,客户端-->建造者-->对象,将建造的职责抽离出来;二是这种类似于流式的编程方式让我感觉很爽,简洁.但是从根本上来看,调用者实际上仍然参与了具体对象的构造细节,如果需求扩展的话,我们仍然需要修改调用者的调用代码.我们可以说这是建造者的一种应用场景,能帮我们实现一种流式编程方式,但是从面向对象的角度来讲,这种应用场景下的建造者模式对于代码架构来讲,并没有实质上的提升.\n## 举例2\n个人理解:**建造者模式更适合对象的组成相对固定,构建流程相对固定,但表现不固定的情况**  举个例子来讲,我们用的很多软件并非大而全,真正厉害的是他们的插件,各种各样的插件提供丰富的功能,比如zsh/sublime/eclipse/idea,老外的设计思想很多就是**面向接口编程**,我只提供标准,那么基于这个标准我可以进行各种扩展.我们就举一个最简单的主题插件的例子,用idea或eclipse的都知道可以换主题,github上也有大量的主题配置文件,假如让我们来设计这种换主题的操作,我们怎么搞:\n### 第一步 抽象概念\n主题包括啥?背景(颜色,图片,...)/字体(颜色,字号,字体...)/代码高亮(语言,模板,...)/动态效果(...)\n{% codeblock 主题类 lang:java %}\npackage com.crazymonkey.builder;\n\n/**\n * 主题类,是我们要构造的最终对象 包含上面提到的实体\n */\npublic class Theme {\n\npackage com.crazymonkey.builder;\n/**\n * 主题类,是我们要构造的最终对象\n */\npublic class Theme {\n    //背景\n    private BackGround backGround;\n    //字体\n    private Font font;\n    //代码高亮\n    private CodeHighLight codeHighLight;\n\n    public BackGround getBackGround() {\n        return backGround;\n    }\n    public void setBackGround(BackGround backGround) {\n        this.backGround = backGround;\n    }\n    public Font getFont() {\n        return font;\n    }\n    public void setFont(Font font) {\n        this.font = font;\n    }\n    public CodeHighLight getCodeHighLight() {\n        return codeHighLight;\n    }\n    public void setCodeHighLight(CodeHighLight codeHighLight) {\n        this.codeHighLight = codeHighLight;\n    }\n}\n{% endcodeblock %}\n\n{% codeblock 背景类 lang:java %}\npackage com.crazymonkey.builder;\n\npublic class BackGround {\n\n    //背景颜色\n    private String color;\n    //背景图片地址\n    private String imageUrl;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getImageUrl() {\n        return imageUrl;\n    }\n\n    public void setImageUrl(String imageUrl) {\n        this.imageUrl = imageUrl;\n    }\n}\n{% endcodeblock %}\n\n\n{% codeblock 字体类 lang:java %}\npackage com.crazymonkey.builder;\n\npublic class Font {\n    //字体颜色\n    private String color;\n    //字号\n    private String size;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getSize() {\n        return size;\n    }\n\n    public void setSize(String size) {\n        this.size = size;\n    }\n}\n\n{% endcodeblock %}\n\n{% codeblock 代码高亮类 lang:java %}\npackage com.crazymonkey.builder;\n\nimport java.util.Map;\n\npublic class CodeHighLight {\n    //语言对应的模版id\n    private Map<String,String> langTemplateMap;\n\n    //是否开启代码高亮\n    private boolean effective;\n\n    public Map<String, String> getLangTemplateMap() {\n        return langTemplateMap;\n    }\n\n    public void setLangTemplateMap(Map<String, String> langTemplateMap) {\n        this.langTemplateMap = langTemplateMap;\n    }\n\n    public boolean isEffective() {\n        return effective;\n    }\n\n    public void setEffective(boolean effective) {\n        this.effective = effective;\n    }\n}\n{% endcodeblock %}\n### 开始构造\n我们已经有了基础的数据结构和简单的构成关系,现在我们想创建一个Theme类怎么搞呢,如果你还说new一个Theme对象,然后一个一个set属性,那么请面壁十分钟.我们在整个关系体系中抽象出一个建造者的概念用来实现Theme对象的构造:\n{% codeblock 抽象主题建造者类 lang:java %}\n\tpackage com.crazymonkey.builder;\n\n\tpublic interface ThemeBuilder {\n\n\t    void buildBackGround();\n\n\t    void buildFont();\n\n\t    void buildCodeHighLight();\n\n\t    Theme build();\n\t}\n\n{% endcodeblock %}\nOK 假设我是Idea的开发者我的工作就做完了,我就定义一个接口,给你提供约束,告诉你们一个主题都有哪些组成部分,最终要构建成个什么样子,具体你们想开发成啥样就啥样呗,比如我们按照上面的约定,实现一个亮色主题:\n{% codeblock lang:java %}\n\tpackage com.crazymonkey.builder;\n\n\timport java.util.HashMap;\n\n\tpublic class LightThemeBuilder implements  ThemeBuilder {\n\n\t    Theme theme;\n\n\t    LightThemeBuilder(Theme theme){\n\t        this.theme =  theme;\n\t    }\n\t    @Override\n\t    public void buildBackGround() {\n\t        BackGround bg = new BackGround();\n\t        bg.setColor(\"black\");\n\t        bg.setImageUrl(\"http://xxxx/xxx\");\n\t        theme.setBackGround(bg);\n\t    }\n\n\t    @Override\n\t    public void buildFont() {\n\t        Font font = new Font();\n\t        font.setColor(\"green\");\n\t        font.setSize(\"12\");\n\t        theme.setFont(font);\n\t    }\n\n\t    @Override\n\t    public void buildCodeHighLight() {\n\t        CodeHighLight chl = new CodeHighLight();\n\t        chl.setEffective(true);\n\t        chl.setLangTemplateMap(new HashMap<>());\n\t        theme.setCodeHighLight(chl);\n\t    }\n\n\t    @Override\n\t    public Theme build() {\n\t        return theme;\n\t    }\n\t}\n{% endcodeblock %}\n在这里演示的只是简单的new一个背景对象,字体对象什么的,其实对象的各种属性值完全可以从配置文件读取啊,从数据库读取啊,然后你再把你需要的配置文件什么的和你的代码打个包,放到人家指定的位置,一个主题插件不就完成了么.我们看下调用者:\n{% codeblock lang:java %}\n    public static void main(String[] args) {\n        ThemeBuilder tb = new LightThemeBuilder(new Theme());\n        tb.buildBackGround();\n        tb.buildCodeHighLight();\n        tb.buildFont();\n        Theme theme = tb.build();\n        System.out.println(theme);\n    }\n{% endcodeblock %}\n### 分析\n其实我们实际上是用一个继承关系来屏蔽了Theme对象的具体构造细节,我们只需要告诉具体建造者,给我造背景,但是不需要指定造什么样的背景,实际上是将构造Theme对象的职责抽象到各种水平扩展的构造者身上,但是作为调用者来讲,我们最终只获取Theme对象,并不关心是怎么造出来的,所以我们引入一个指挥官的概念.\n### 指挥官\n{% codeblock lang:java %}\n\tpackage com.crazymonkey.builder;\n\n\tpublic class ThemeBuildDirector {\n\n\t    ThemeBuilder tb;\n\n\t    ThemeBuildDirector(ThemeBuilder tb){\n\t        this.tb = tb;\n\t    }\n\n\t    public Theme direct(){\n\t        tb.buildFont();\n\t        tb.buildCodeHighLight();\n\t        tb.buildBackGround();\n\t        return tb.build();\n\t    }\n\t}\n{% endcodeblock %}\n这时候,调用者只需要告诉指挥官,我需要一个什么样的Theme,那么指挥官就会调用具体的建造者去造了,而且调用者完全不需要关注对象的建造细节,也不用担心造的部件不完整,这一切都是由指挥官管辖,如果增加需求的话,也不会影响调用者的逻辑,而是由指挥官进行具体建造任务的协调.\n{% codeblock lang:java %}\n public static void main(String[] args) {\n        Theme theme = new ThemeBuildDirector(new LightThemeBuilder(new Theme())).direct();\n        System.out.println(theme);\n    }\n{% endcodeblock %}\n看一眼结果:\n<img src=\"设计模式-建造者/builderresult.png\">\n看完这个例子再看我前面说的那句话,就不难理解了,一个Theme组成部分相对固定,字体啊,背景啊什么的,并且建造流程相对固定,就是造那几部分内容呗,但是表现不固定,什么是表现,就是不同Theme对象的业务形态:白的,黑的,绿的.这种情况我们用建造者可以做到很好的扩展和动态替换.\n\n## 总结\n上面的两个例子实际上是建造者的两种不同的应用场景,我们通过用这种设计模式来达成特定的效果,其实所有设计模式都是一样,有的时候我们可能只需要用到其中的一部分思想就可以了,没必要生搬硬套,掌握设计模式的原则即可.我们再回头看下设计模式的那几项原则,理解一下再建造者模式上的体现,思考一下是怎么一步步封装职责,做到动态替换的,相信你会对设计思想有更深层次的理解.\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["设计模式"]},{"title":"设计模式--单例","url":"/2019/04/11/设计模式-单例/","content":"## 应用场景\n顾名思义,单例就是某个类在JVM里只有一个实例对象.为什么会产生单例这种设计模式呢,个人理解,从两方面来解释,一方面是性能:假设某个类的实例非常重量,每次实例化耗时耗资源,那么我们考虑将这个实例在堆中只维护一份,比如我们的系统常常有读取配置文件的需求,那么我们完全可以只读一次就把配置文件中的内容加载进JVM以对象的形式维护,处于性能考虑,没必要每次都是实例化;另一方面是逻辑,比如数据库连接池,或者XXXManager这些管理类型的类,一个系统中有一个就够了,就好比一个房子有一个大管家就可以了,两个就容易打架,处于这种逻辑考虑,可以运用单例的设计模式来处理.\n## 举例\n就拿上面的读取配置文件的例子来学习一下单例模式,假设我们有一个系统,需要和微信对接,获取用户的微信头像,那么我们肯定得知道微信的服务地址吧,写死在程序里这种硬编码的方式可维护性比较差,所以我们可以考虑把微信的接口地址配到配置文件中,然后通过代码把配置读进来,实例化一个配置类:\n配置文件config.properties:\n {% codeblock lang:js %}\n \t#微信接口地址\n \twechatUrl = https://xxx/xxx/xxx\n \t#除了url有可能会有一些其他的配置用来进行参数签名之类的\n \twechatKey = xxxxxx\n \twechatSecret = xxxxxx\n {% endcodeblock %}\n下面我们用一个单例模式来实现上述读取配置文件的过程:\n {% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.util.Properties;\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance;\n\n    public String getWechatUrl() {\n        return wechatUrl;\n    }\n\n    public String getWechatKey() {\n        return wechatKey;\n    }\n\n    public String getWechatSecret() {\n        return wechatSecret;\n    }\n\n    //暴露一个public类型的get方法用来获取实例信息\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n\n    private ConfigConstants() throws Exception {\n        Properties properties = new Properties();\n        properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n        this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n        this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n        this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n    }\n\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n 看一眼运行的结果:\n <img src=\"设计模式-单例/singletonresult.png\">\n 我们可以发现两次取得的是同一个实例,针对上面的例子我们可以总结单例的创建过程:\n 1. **私有的构造方法**:防止该类在别处被实例化:\n 2. **本类中定义一个static对象**:有人会问,为什么是static类型?个人理解:不考虑反射或者反序列化等特殊创建对象的方式(后面会提),我们只考虑常规的访问成员变量的方式有两种:第一种是通过new关键字创建一个对象,然后访问对象中的属性;另一种方式是直接通过类名来访问该类的静态变量,构造方法私有化之后我们无法在外部通过对象实例的方式访问该对象的成员属性,那么我们只能通过类名.方法名的方式来访问,所以就要求方法是static的,static的方法又不能直接拿非static的引用,因此必须要求成员变量instance是static的.\n 3. **提供可访问该对象的公有方法**;\n## 单例的写法\n单例的实现有很多种方式,在这里我们只讨论**能在项目中应用的**实现方式,比如上面那个例子在多线程环境中是无法使用的,两个线程同时进入getInstance的if判断,那么就会产生两个实例.\n### 懒汉模式(同步方法)\n 上面我们举的例子实际上是一种懒汉的模式,之所以称之为懒汉,是因为可以做到懒加载,在使用对象实例的时候才加载,而不是在类加载的时候就加载,既然上面的例子非线程安全,那么最简单的,我们在方法上加个锁让两个线程互斥访问就可以了:\n {% codeblock lang:java %}\n\tpublic static synchronized ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                instance = new ConfigConstants();\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\n上面这种锁方法的做法效率不高(其实只有第一次实例化的时候需要加锁,以后直接取就可以了,但是将整个方法进行同步就意味着每次获取实例都需要互斥访问),所以常用的是一种双重检查的方式:\n### 懒汉模式(Double-Check)\n {% codeblock lang:java %}\n \tprivate volatile static ConfigConstants instance;\n    public static ConfigConstants getInstance() {\n        try {\n            if (instance == null) {\n                synchronized (ConfigConstants.class) {\n                    if (instance == null) {\n                        instance = new ConfigConstants();\n                    }\n                }\n            }\n            return instance;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n  {% endcodeblock %}\nAB两个线程同时进入if判断,假设A获得锁之后进入第二个if判断,这时候发现instance为空,遂创建一个instance实例,当A获得锁的时候B只能等待锁,当A完成了实例化的过程,释放了锁,此时B获得锁,经过if判断,发现已经有实例了,所以就不会再创建实例,实际上这种方式和同步方法相比是更细粒度的串行化.\n和普通的懒汉模式相比还有一点小差别,就是我们的实例变量采用了volatile修饰,这是为了避免**DCL失效**的问题,简单解释一下:\nJVM的内存模型是主存和线程内存,每个线程在工作的时候先从主存copy一份数据到自己的工作内存,实例化的过程实际就是分配空间,构造对象,将引用指向对象,搞完了再把这个对象的引用刷到主存中去,然后另一个线程就能看到了.逻辑没问题,但实现上会复杂一些,java编译器的指令优化加上底层cpu的并行调整,有可能造成一分配空间线程A就搞个指针指上去了,先指上去再构造对象,然后对象构造一半,又把instance引用刷到主存中去了,这时候底层cpu时间片切换,线程B拿到了时间片进入if条件,发现主存中的instance非空了,所以直接返回实例,这时候拿到的是堆中的一个半成品对象,在操作这个对象的时候就会出问题.整个现象就叫DCL失效,为了解决这个问题我们将引用声明成volatile,那么线程A对instance的操作可以实时对线程B可见.如果想深入了解,可以看一下java的内存模型,和多线程相关的东西.\n### 饿汉模式\n饿汉模式和懒汉模式对比来说,就是类在初始化的时候就加载其中的对象,这时JVM的类加载机制保证了单线程的操作,因此我们不用加任何锁就可以保证线程安全,饿汉模式可以利用静态变量或者静态代码块来实现:\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\nimport java.io.IOException;\nimport java.util.Properties;\n\n/**\n * 配置文件读取类\n */\npublic class ConfigConstants {\n\n    private String wechatUrl = \"\";\n\n    private String wechatKey = \"\";\n\n    private String wechatSecret = \"\";\n\n    private static ConfigConstants instance = new ConfigConstants();\n\n//注释的部分采用static代码块加载,和上面的采用静态变量的方式效果一样\n//    private static ConfigConstants instance;\n//\n//    static{\n//        instance = new ConfigConstants();\n//    }\n    public static ConfigConstants getInstance() {\n       return instance;\n    }\n    @Override\n    public String toString() {\n        return \"ConfigConstants{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    private ConfigConstants()  {\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        ConfigConstants c2 = ConfigConstants.getInstance();\n        System.out.println(c1.equals(c2));\n        System.out.println(c1.toString());\n    }\n}\n {% endcodeblock %}\n### 内部类\n只列出关键代码,构造方法之类的可以看上面\n{% codeblock lang:java %}\n    //定义静态内部类\n    private static class ConfigConstantsHolder{\n        private static final ConfigConstants instance = new ConfigConstants();\n\n    }\n\n    public static ConfigConstants getInstance() {\n        return ConfigConstantsHolder.instance;\n    }\n {% endcodeblock %}\n静态内部类和饿汉模式一样,也是利用了虚拟机的类加载机制来保证单例的,但是和饿汉模式不同,在外部类ConfigConstants加载的时候并不会加载内部类,而是在调用getInstance的时候去取ConfigConstantsHolder的成员变量的时候才被初始化,此时instance实例才真正被创建出来,因此我们也可以认为是懒加载的一种.\n### 枚举类\n{% codeblock lang:java %}\npackage com.crazymonkey.singleton;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic enum ConfigEnum {\n    INSTANCE;\n\n    private String wechatUrl=\"\";\n    private String wechatKey=\"\";\n    private String wechatSecret = \"\";\n\n    ConfigEnum(){\n\n        try {\n            Properties properties = new Properties();\n            properties.load(Object.class.getResourceAsStream(\"/config.properties\"));\n            this.wechatUrl = properties.getProperty(\"wechatUrl\", \"\");\n            this.wechatKey = properties.getProperty(\"wechatKey\", \"\");\n            this.wechatSecret = properties.getProperty(\"wechatSecret\", \"\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public String toString() {\n        return \"ConfigEnum{\" +\n                \"wechatUrl='\" + wechatUrl + '\\'' +\n                \", wechatKey='\" + wechatKey + '\\'' +\n                \", wechatSecret='\" + wechatSecret + '\\'' +\n                '}';\n    }\n    public static void main(String[] args) {\n        System.out.println( ConfigEnum.INSTANCE== ConfigEnum.INSTANCE);\n        System.out.println(ConfigEnum.INSTANCE);\n    }\n}\n{% endcodeblock %}\n枚举类本身就是单例,我们可以利用这个特性实现我们单例的应用场景.\n## 单例的破坏\n我们上面讨论的单例的构造过程中有很重要的一点,就是构造方法私有,那么我们把构造方法藏起来了,别人就会老老实实调用我们的getInstance方法么,毕竟除了new java还提供了其他的生成对象的方式,比如下面这两种:\n### 反射\n{% codeblock lang:java %}\n   public static void main(String[] args) {\n        ConfigConstants c1 = ConfigConstants.getInstance();\n        Constructor[] constructors = ConfigConstants.class.getDeclaredConstructors();\n        if(constructors.length>0){\n            try {\n                System.out.println(constructors[0]);\n                ConfigConstants c2 = (ConfigConstants)(constructors[0].newInstance(null));\n                System.out.println(c1.equals(c2));\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n{% endcodeblock %}\n看一眼结果,通过单例生成的对象和我们通过getInstance方法生成的对象不是一个:\n<img src =\"设计模式-单例/breaksingleton.png\">\n解决方法就是增加标志位,第一次创建的时候将标志位置true,在构造方法中进行判断,代码不贴了,可以按这种思路自己实现\n### 反序列化\n\n{% codeblock lang:java %}\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"/Users/yangsimeng/Documents/test/test.obj\"));\n            oos.writeObject(ConfigConstants.getInstance());\n            //Read Obj from file\n            File file=new File(\"/Users/yangsimeng/Documents/test/test.obj\");\n            ObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n            ConfigConstants newInstance=(ConfigConstants)ois.readObject();\n            //判断是否是同一个对象\n            System.out.println(newInstance==ConfigConstants.getInstance());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n    }\n{% endcodeblock %}\n如果单例类实现了serializble接口,那么是可以被序列化的,如果序列化之后再反序列化,那么将会生成不同的对象,解决方式就是不让他序列化或者定义readResolve方法返回指定的对象即可:\n{% codeblock lang:java %}\n    private Object readResolve(){\n        return instance;\n    }\n{% endcodeblock %}\n\n","categories":["设计模式"]},{"title":"Mysql索引原理--树形结构的应用","url":"/2019/04/10/Mysql索引原理-树形结构的应用/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--B树和B+树","url":"/2019/04/10/Mysql索引原理-B树和B-树/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--树结构的基本概念","url":"/2019/04/10/Mysql索引原理-树结构的基本概念/","content":"### 写在前面\n&emsp;&emsp;这个系列的文章主要目的就是了解Mysql常用的InnoDB存储引擎的Btree类型索引的内部实现原理.在这之前先了解一下什么是树形结构吧,循序渐近别着急.\n&emsp;&emsp;树形结构实际上就是众多数据结构中的一种,什么是数据结构呢,就是组织数据的方式,什么是数据的组织方式呢?现代社会,我们生活被各种数据包围,知乎看到的文章,游戏刷出来的装备,去超市看到的薯片的配料表,杨二狗涨了300块钱工资...数据的使命就是被消费,说白了就是存储和查找.怎么存的更省地方,怎么找的更快,数据怎么尽可能快速有效的被消费.有一帮人绞尽脑汁的想出了各种各样的数据组织方式,对现实世界的应用场景进行抽象,各种数据结构就产生了,树型结构就是其中的一种,是对一种非线形关系的抽象.\n\n### 基本概念\n<div style='text-align:center'>\n\t<img width=300 src=\"Mysql索引原理--树结构的基本概念/simpletree.png\" >\n</div>\n- 根节点:A就是树的根节点 一棵树的根节点数目可以是0(空树)或1\n- 父节点/父亲节点/双亲节点:当前节点的上一级节点 B就是C的父节点 A是B的父节点\n- 子节点/孩子节点:和父节点相对应 C\n- 兄弟节点:\n- 祖先:\n- 子孙:\n- 度:\n- 层:\n- 高度:\n- 森林\n\n### 树的种类及特性\n\n\n### 树的存储表示\n<!--\n{% codeblock [测试代码] [lang:java]  %}\n\tpublic class Test(){\n\t\tpublic static void main(String [] args){\n\n\n\t}\n\n\n\t}\n\n\t\n{% endcodeblock %}\n-->\n\n\n\n\n\n<!-- <img width=200 src=\"Mysql索引原理--树结构的基本概念/1553657360617.jpg\" >  -->\n\n","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"设计模式-工厂","url":"/2019/03/25/设计模式-工厂/","content":"## 应用场景\n&emsp;&emsp;工厂是干嘛的,生产东西的呗,生产东西干什么,用呗.这个逻辑平移到编码领域,更确切的说OO编码,工厂是用来干嘛的,生产对象的,生产对象干什么,实现特定的功能,为什么对象不直接New要通过工厂生产--Ok,举个例子看一下.\n&emsp;&emsp;你看到一个视频微博“2019年常规赛詹姆斯精彩镜头”,你知道怎么来的么?实际上背后有一个视频剪辑平台,视频编辑把一个个的镜头挑出来->剪成一个个小段->拼接->给视频起名字->推送到新浪微博.这些过程抽象一下实际上就是一个个的任务,比如我们设计一个任务表来存这些任务 任务类型分别叫 SPLIT(剪辑)->COMPOSE(拼接)->RENAME(起名字)->PUSH(推送) 编辑们干活的时候数据库产生很多条任务记录需要处理 这些任务分属于不同任务类型 这时候来吧 写代码处理一下这些任务吧\n## 处理\n刚上来可能这么处理,下面这个taskList模拟从数据库取出来的任务列表:\n\n {% codeblock lang:java %}\n\tpackage com.crazymonkey;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\tpublic class TestPattern {\n    //模拟任务类\n    class Task {\n        //任务类型\n        String taskType;\n        //视频Id\n        String targetId;\n        Task(String taskType, String targetId) {\n            this.taskType = taskType;\n            this.targetId = targetId;\n        }\n    }\n    public static void main(String[] args) {\n        //*********准备数据开始********\n        List<Task> taskList = new ArrayList<>();\n        TestPattern tp = new TestPattern();\n        taskList.add(tp.new Task(\"SPLIT\", \"111\"));\n        taskList.add(tp.new Task(\"COMPOSE\", \"222\"));\n        taskList.add(tp.new Task(\"RENAME\", \"111\"));\n        taskList.add(tp.new Task(\"TEST\", \"111\"));\n        taskList.add(tp.new Task(\"PUSH\", \"222\"));\n        taskList.add(tp.new Task(\"PUSH\", \"333\"));\n        //********准备数据结束 下面是核心代码*********\n        for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理拆条任务-->\" + task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理合成任务-->\" + task.targetId);\n            } else if (\"RENAME\".[[equalsIgnoreCase]](task.taskType)) {\n                System.out.println(\"处理起名任务-->\" + task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理推送任务-->\" + task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n    }\n\t}\n {% endcodeblock %}\n## 分析\n我们反过来从基础篇的设计原则看一下 这样写为什么不好:  \n1.这个方法处理了所有逻辑,对象职责不清晰,调用者和功能提供者之间职责不清晰\n2.如果这时候业务需求改了增加一个审核的任务类型怎么办,就得改现有代码增加if判断\n3.具体实现逻辑我只输出了一行,但真实的业务场景的复杂逻辑针对每一种任务都得有很多代码来处理,加一起得写多少代码,一旦重命名任务报错想排查的话怎么搞,想死的心都有了吧  \n## 改进\n&emsp;&emsp;在代码优化的过程中最基础有效的首先就是***单一职责***,对象的单一职责和方法的单一职责,第一步先保证一个对象只干一件事:\n {% codeblock  lang:java %}\n    for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandler().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n               new ComposeTaskHandler().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandler().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n              new PushTaskHandler().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n &emsp;&emsp;可以看到我针对每种任务类型分别创建一个对象,并且提供一个handleTask方法来进行处理各自的业务逻辑,随便取一个出来看看,不一一列举了:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler {\n            public void handleTask(String targetId){\n                System.out.println(\"处理拆条任务-->\" + targetId);\n                //真实的处理逻辑 可能有很多行    \n            }\n    }\n  {% endcodeblock %}\n## 分析\n我们解决了一部分问题,分离了一些职责出去,这时候如果拆条任务处理出错了,我们也很好定位了,直接去对应的类里面找代码就可以了,但是还有一些问题待解决:第一,调用者(Main)直接持有每个任务处理类的对象,这是一种强耦合的关系引用;第二,调用者的职责是调用,现在仍然承担了判断该用哪个Handler的职责;第三,每个Handler都有相同的行为,就是处理任务,我们可以对他们进行更抽象的约束.为了解决这三点问题,我们先来看下简单工厂模式:\n## 简单工厂模式\n首先 声明一个接口 用来抽象我们上面创建的handler,定义handlerTask方法来处理任务:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface TaskHandler {\n        \n       void handleTask(String targetId);\n    }\n {% endcodeblock %}\n 每个任务的实现类实现该接口,还是拿一个举例:\n   {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler implements TaskHandler {\n        @Override\n        public void handleTask(String targetId){\n            System.out.println(\"处理拆条任务-->\" + targetId);\n            //真实的处理逻辑 可能有很多行\n        }\n    }\n {% endcodeblock %}\n\n然后我们创建一个工厂,用来产生TashHandler,工厂的作用就是分离调用者原本的创建Handler的职责,返回值是TaskHandler,这是一个典型的***面相接口编程***的应用运行时才决定示例化哪个对象 这也就是Java三大特性之一的多态 扯远了看工厂:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class TaskHandlerSimpleFactory {\n        //注意返回值是一个接口类型 \n       static TaskHandler create(String taskType){\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n               return new SplitTaskHandler();\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) { \n                return new ComposeTaskHandler(); \n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n              return new RenameTaskHandler();\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n               return new PushTaskHandler();\n            } else {\n                return null;\n            }\n        }\n    }\n {% endcodeblock %}\n 有了简单工厂我们再看调用者:\n{% codeblock  lang:java %}\n     for (Task task : taskList) {\n             TaskHandlerSimpleFactory.create(task.taskType).handleTask(task.targetId);\n        }\n {% endcodeblock %}\n 怎么样 是不是很清晰了\n## 分析\n现在再来看看我们引入简单工厂之前那个版本的问题是否得到了解决:\n- 分离出具体handler职责,每种任务只处理自己的业务逻辑\n- 分离出工厂职责,专门负责生产任务的handler\n- 分离出调用者职责,最终形成 调用者-工厂-Handler 的调用关系\n- 增加一种任务类型的话只需要增加一个被TaskHandler接口约束的类,实现handleTask方法,并通过简单工厂生产即可 不影响调用者和其他Handler\n有人可能会问了增加任务类型的话不还得修改简单工厂类么,这不违反开放-封闭原则么,Ok 我们来看工厂方法模式\n## 工厂方法模式\n我们想让简单工厂的职责对修改关闭,那我我们只能将工厂进行更进一步的抽象,才能将变化提取出去(慢慢理解啊).第一步,我们抽象出一个工厂接口:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface HandlerFactory {\n        TaskHandler create();\n    }\n {% endcodeblock %}\n然后让具体的业务工厂去实现这个接口,拿一个举例:\n{% codeblock  lang:java %}\n   package com.crazymonkey;\n    public class SplitTaskHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler create() {\n            return new SplitTaskHandler();\n        }\n    }\n {% endcodeblock %}\n 这时候由于我们抽象了工厂的概念 因此每一个Handler的工厂可以直接生产对应的Handler对象来处理具体的任务,那原来的if判断去哪了,看调用者:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                new ComposeTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                new PushTaskHandlerFactory().create().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n## 分析\n看一下我们刚才的问题解决了没有,这个时候你增加一个审核任务类型怎么办,直接创建一个CheckHandlerFactory 通过这个工厂去生产CheckHandler处理具体的任务,有人说不对啊,你增加一种类型不还得改调用者么,加个if......这不也是违反开闭原则么?大哥,你加需求肯定得加判断啊,但是为什么还会产生工厂这种模式呢,Ok下面是自己理解,不保对啊:其实就是一个词 **类的职责**,我们把关注点放在生产Handler这个职责上:简单工厂的职责就是生产handler,增加任务类型Check就得改工厂,不改行不行呢?不行!因为实现不了生产CheckHandler的功能;同样的关注点我们看工厂模式,生产handler这个职责:需要改东西么?不需要!我只需要新建就好了,其他已有的东西都不需要动.所以在生产handler这个职责角度上我们说工厂模式比简单工厂扩展性更强.调用者是另一个角度的问题,反正生产handler的过程我工厂是极好的,handler也生产出来了,你调用者爱调不调呗.我这个模式解决的是 ***生产***这个角度的问题,调用者的变化并不影响生产的过程,因此我们可以理解他是符合开闭原则的.\n说了一大堆,平时用的最多的还是简单工厂,因为简单.\n## 抽象工厂模式\n这个模式其实用的也比较少,但是既然说工厂了,也不能不提,假想一个应用场景,假设我们需要针对不同的任务类型做日志记录,比如拆条的记录到txt里,打包的记录到mongodb中,推送的不处理,怎么弄呢,有人说直接写到具体handler的handletask方法里不就好了么,对!如有有这种需求的话,大多数情况也是这么干的,为什么呢,因为简单.但是从职责划分的角度上来讲,日志记录我们也可以说属于调用者的职责,具体handler只管处理任务就好,不需要干其他的,对吧.原来我们是一条线,生产taskHandler,这时候我们多了一条线,用来生产logHandler,Ok,我们来看,既然想要生产loghandler 那么就需要抽象出来一个接口:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public interface LogHandler {\n        \n      void  handleLog(String targetId);\n    }\n{% endcodeblock %}\n然后这个logHandler得通过工厂生产出来啊,所以要扩展一下上面的工厂接口,让它也能生产logHandler,\n {% codeblock  lang:java %}\n  package com.crazymonkey;\n\n    public interface HandlerFactory {\n        //生产TaskHandler\n      TaskHandler createTaskHandler();\n      \n        //生产LogHandler\n      LogHandler createLogandler();\n    }\n{% endcodeblock %}\n具体实现,还拿拆条任务举例:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public class SplitHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler createTaskHandler() {\n            return new SplitTaskHandler();\n        }\n\n        @Override\n        public LogHandler createLogandler() {\n            return new SplitLogHandler();\n        }\n    }\n{% endcodeblock %}\nOk,现在我们的工厂有了两条生产线,可以生产taskHandler和logHandler,调用者该怎么做很明显了吧:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                //看这里 一个factory生产了两条线\n                HandlerFactory hf =   new SplitHandlerFactory();\n                hf.createTaskHandler().handleTask(task.targetId);\n                hf.createLogandler().handlerLog(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n{% endcodeblock %}\n## 分析\n其实对于实现上来讲 就是扩展了一下HandlerFactory接口,加了个方法,跟以前没啥区别,但是整个的设计思想实际上是有一个更深的抽象,因此叫抽象工厂(个人理解)\n## 总结\n设计模式第一篇,总结了一个工作中常用的工厂模式,举了一个实际工作中的例子作为参考.模式类图网上有的是,可以随便找一个看看,可以加深理论上的理解,其实所有的设计模式思想都是相通的,高内聚,低耦合,面相接口编程,单一职责.用到工厂的情况还有很多种,比如处理不同的数据,翻译不同的参数关键一点就是抽象出要生产的Product,其他的问题就套模式就好了.OK,这篇文章就这样,有问题加我微信.","categories":["设计模式"]},{"title":"设计模式-理论基础","url":"/2019/03/22/设计模式-理论基础/","content":"\n&emsp;&emsp;各种设计模式实际上就是一种前人总结的代码设计的经验之谈,是一种编程的思维方式.运用他们可以帮我们写出简洁可扩展性强的代码.  \n&emsp;&emsp;网上的设计模式的文章大多都是举一两个简单的例子进行解释,但是不可否认 有的时候demo和实际应用场景还有一些距离,虽然明白了原理,但是真到了实际写代码的过程中不知道怎么用.遇到了冗余代码想优化也无从下手.这个设计模式的专题目的就是尽量结合实际项目的应用场景,对常用的设计模式进行举例说明,使得使用者对于各种常用设计模式有着更直观的认识.  \n下面是一些设计原则和方法论,刚开始可能理解的不深,但是熟悉了几个常用的设计模式之后,回头看这些抽象的总结就会发现,所有的设计模式都是这些方法论的具体实践,我们不讲理论,我们只是理论的搬运工:\n- 单一职责原则  \n- 开放封闭原则\n- 里氏替换原则\n- 依赖倒置原则\n- 接口隔离原则\n- 迪米特法则  \n详细的理论解释请参考:<https://www.cnblogs.com/dolphin0520/p/3919839.html>\n\n\n","categories":["设计模式"]}]