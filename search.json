[{"title":"设计模式-理论基础","url":"/2019/04/11/设计模式-理论基础/","content":"\n&emsp;&emsp;各种设计模式实际上就是一种前人总结的代码设计的经验之谈,是一种编程的思维方式.运用他们可以帮我们写出简洁可扩展性强的代码.  \n&emsp;&emsp;网上的设计模式的文章大多都是举一两个简单的例子进行解释,但是不可否认 有的时候demo和实际应用场景还有一些距离,虽然明白了原理,但是真到了实际写代码的过程中不知道怎么用.遇到了冗余代码想优化也无从下手.这个设计模式的专题目的就是尽量结合实际项目的应用场景,对常用的设计模式进行举例说明,使得使用者对于各种常用设计模式有着更直观的认识.  \n下面是一些设计原则和方法论,刚开始可能理解的不深,但是熟悉了几个常用的设计模式之后,回头看这些抽象的总结就会发现,所有的设计模式都是这些方法论的具体实践,我们不讲理论,我们只是理论的搬运工:\n- 单一职责原则  \n- 开放封闭原则\n- 里氏替换原则\n- 依赖倒置原则\n- 接口隔离原则\n- 迪米特法则  \n详细的理论解释请参考:<https://www.cnblogs.com/dolphin0520/p/3919839.html>\n\n\n","categories":["设计模式"]},{"title":"设计模式-工厂","url":"/2019/04/11/设计模式-工厂/","content":"## 应用场景\n&emsp;&emsp;工厂是干嘛的,生产东西的呗,生产东西干什么,用呗.这个逻辑平移到编码领域,更确切的说OO编码,工厂是用来干嘛的,生产对象的,生产对象干什么,实现特定的功能,为什么对象不直接New要通过工厂生产--Ok,举个例子看一下.\n&emsp;&emsp;你看到一个视频微博“2019年常规赛詹姆斯精彩镜头”,你知道怎么来的么?实际上背后有一个视频剪辑平台,视频编辑把一个个的镜头挑出来->剪成一个个小段->拼接->给视频起名字->推送到新浪微博.这些过程抽象一下实际上就是一个个的任务,比如我们设计一个任务表来存这些任务 任务类型分别叫 SPLIT(剪辑)->COMPOSE(拼接)->RENAME(起名字)->PUSH(推送) 编辑们干活的时候数据库产生很多条任务记录需要处理 这些任务分属于不同任务类型 这时候来吧 写代码处理一下这些任务吧\n## 处理\n刚上来可能这么处理,下面这个taskList模拟从数据库取出来的任务列表:\n\n {% codeblock lang:java %}\n\tpackage com.crazymonkey;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\tpublic class TestPattern {\n    //模拟任务类\n    class Task {\n        //任务类型\n        String taskType;\n        //视频Id\n        String targetId;\n        Task(String taskType, String targetId) {\n            this.taskType = taskType;\n            this.targetId = targetId;\n        }\n    }\n    public static void main(String[] args) {\n        //*********准备数据开始********\n        List<Task> taskList = new ArrayList<>();\n        TestPattern tp = new TestPattern();\n        taskList.add(tp.new Task(\"SPLIT\", \"111\"));\n        taskList.add(tp.new Task(\"COMPOSE\", \"222\"));\n        taskList.add(tp.new Task(\"RENAME\", \"111\"));\n        taskList.add(tp.new Task(\"TEST\", \"111\"));\n        taskList.add(tp.new Task(\"PUSH\", \"222\"));\n        taskList.add(tp.new Task(\"PUSH\", \"333\"));\n        //********准备数据结束 下面是核心代码*********\n        for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理拆条任务-->\" + task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理合成任务-->\" + task.targetId);\n            } else if (\"RENAME\".[[equalsIgnoreCase]](task.taskType)) {\n                System.out.println(\"处理起名任务-->\" + task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                System.out.println(\"处理推送任务-->\" + task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n    }\n\t}\n {% endcodeblock %}\n## 分析\n我们反过来从基础篇的设计原则看一下 这样写为什么不好:  \n1.这个方法处理了所有逻辑,对象职责不清晰,调用者和功能提供者之间职责不清晰\n2.如果这时候业务需求改了增加一个审核的任务类型怎么办,就得改现有代码增加if判断\n3.具体实现逻辑我只输出了一行,但真实的业务场景的复杂逻辑针对每一种任务都得有很多代码来处理,加一起得写多少代码,一旦重命名任务报错想排查的话怎么搞,想死的心都有了吧  \n## 改进\n&emsp;&emsp;在代码优化的过程中最基础有效的首先就是***单一职责***,对象的单一职责和方法的单一职责,第一步先保证一个对象只干一件事:\n {% codeblock  lang:java %}\n    for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandler().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n               new ComposeTaskHandler().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandler().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n              new PushTaskHandler().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n &emsp;&emsp;可以看到我针对每种任务类型分别创建一个对象,并且提供一个handleTask方法来进行处理各自的业务逻辑,随便取一个出来看看,不一一列举了:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler {\n            public void handleTask(String targetId){\n                System.out.println(\"处理拆条任务-->\" + targetId);\n                //真实的处理逻辑 可能有很多行    \n            }\n    }\n  {% endcodeblock %}\n## 分析\n我们解决了一部分问题,分离了一些职责出去,这时候如果拆条任务处理出错了,我们也很好定位了,直接去对应的类里面找代码就可以了,但是还有一些问题待解决:第一,调用者(Main)直接持有每个任务处理类的对象,这是一种强耦合的关系引用;第二,调用者的职责是调用,现在仍然承担了判断该用哪个Handler的职责;第三,每个Handler都有相同的行为,就是处理任务,我们可以对他们进行更抽象的约束.为了解决这三点问题,我们先来看下简单工厂模式:\n## 简单工厂模式\n首先 声明一个接口 用来抽象我们上面创建的handler,定义handlerTask方法来处理任务:\n  {% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface TaskHandler {\n        \n       void handleTask(String targetId);\n    }\n {% endcodeblock %}\n 每个任务的实现类实现该接口,还是拿一个举例:\n   {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class SplitTaskHandler implements TaskHandler {\n        @Override\n        public void handleTask(String targetId){\n            System.out.println(\"处理拆条任务-->\" + targetId);\n            //真实的处理逻辑 可能有很多行\n        }\n    }\n {% endcodeblock %}\n\n然后我们创建一个工厂,用来产生TashHandler,工厂的作用就是分离调用者原本的创建Handler的职责,返回值是TaskHandler,这是一个典型的***面相接口编程***的应用运行时才决定示例化哪个对象 这也就是Java三大特性之一的多态 扯远了看工厂:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public class TaskHandlerSimpleFactory {\n        //注意返回值是一个接口类型 \n       static TaskHandler create(String taskType){\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n               return new SplitTaskHandler();\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) { \n                return new ComposeTaskHandler(); \n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n              return new RenameTaskHandler();\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n               return new PushTaskHandler();\n            } else {\n                return null;\n            }\n        }\n    }\n {% endcodeblock %}\n 有了简单工厂我们再看调用者:\n{% codeblock  lang:java %}\n     for (Task task : taskList) {\n             TaskHandlerSimpleFactory.create(task.taskType).handleTask(task.targetId);\n        }\n {% endcodeblock %}\n 怎么样 是不是很清晰了\n## 分析\n现在再来看看我们引入简单工厂之前那个版本的问题是否得到了解决:\n- 分离出具体handler职责,每种任务只处理自己的业务逻辑\n- 分离出工厂职责,专门负责生产任务的handler\n- 分离出调用者职责,最终形成 调用者-工厂-Handler 的调用关系\n- 增加一种任务类型的话只需要增加一个被TaskHandler接口约束的类,实现handleTask方法,并通过简单工厂生产即可 不影响调用者和其他Handler\n有人可能会问了增加任务类型的话不还得修改简单工厂类么,这不违反开放-封闭原则么,Ok 我们来看工厂方法模式\n## 工厂方法模式\n我们想让简单工厂的职责对修改关闭,那我我们只能将工厂进行更进一步的抽象,才能将变化提取出去(慢慢理解啊).第一步,我们抽象出一个工厂接口:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public interface HandlerFactory {\n        TaskHandler create();\n    }\n {% endcodeblock %}\n然后让具体的业务工厂去实现这个接口,拿一个举例:\n{% codeblock  lang:java %}\n   package com.crazymonkey;\n    public class SplitTaskHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler create() {\n            return new SplitTaskHandler();\n        }\n    }\n {% endcodeblock %}\n 这时候由于我们抽象了工厂的概念 因此每一个Handler的工厂可以直接生产对应的Handler对象来处理具体的任务,那原来的if判断去哪了,看调用者:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                new SplitTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n                new ComposeTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n                new RenameTaskHandlerFactory().create().handleTask(task.targetId);\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n                new PushTaskHandlerFactory().create().handleTask(task.targetId);\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n {% endcodeblock %}\n## 分析\n看一下我们刚才的问题解决了没有,这个时候你增加一个审核任务类型怎么办,直接创建一个CheckHandlerFactory 通过这个工厂去生产CheckHandler处理具体的任务,有人说不对啊,你增加一种类型不还得改调用者么,加个if......这不也是违反开闭原则么?大哥,你加需求肯定得加判断啊,但是为什么还会产生工厂这种模式呢,Ok下面是自己理解,不保对啊:其实就是一个词 **类的职责**,我们把关注点放在生产Handler这个职责上:简单工厂的职责就是生产handler,增加任务类型Check就得改工厂,不改行不行呢?不行!因为实现不了生产CheckHandler的功能;同样的关注点我们看工厂模式,生产handler这个职责:需要改东西么?不需要!我只需要新建就好了,其他已有的东西都不需要动.所以在生产handler这个职责角度上我们说工厂模式比简单工厂扩展性更强.调用者是另一个角度的问题,反正生产handler的过程我工厂是极好的,handler也生产出来了,你调用者爱调不调呗.我这个模式解决的是 ***生产***这个角度的问题,调用者的变化并不影响生产的过程,因此我们可以理解他是符合开闭原则的.\n说了一大堆,平时用的最多的还是简单工厂,因为简单.\n## 抽象工厂模式\n这个模式其实用的也比较少,但是既然说工厂了,也不能不提,假想一个应用场景,假设我们需要针对不同的任务类型做日志记录,比如拆条的记录到txt里,打包的记录到mongodb中,推送的不处理,怎么弄呢,有人说直接写到具体handler的handletask方法里不就好了么,对!如有有这种需求的话,大多数情况也是这么干的,为什么呢,因为简单.但是从职责划分的角度上来讲,日志记录我们也可以说属于调用者的职责,具体handler只管处理任务就好,不需要干其他的,对吧.原来我们是一条线,生产taskHandler,这时候我们多了一条线,用来生产logHandler,Ok,我们来看,既然想要生产loghandler 那么就需要抽象出来一个接口:\n {% codeblock  lang:java %}\n    package com.crazymonkey;\n    public interface LogHandler {\n        \n      void  handleLog(String targetId);\n    }\n{% endcodeblock %}\n然后这个logHandler得通过工厂生产出来啊,所以要扩展一下上面的工厂接口,让它也能生产logHandler,\n {% codeblock  lang:java %}\n  package com.crazymonkey;\n\n    public interface HandlerFactory {\n        //生产TaskHandler\n      TaskHandler createTaskHandler();\n      \n        //生产LogHandler\n      LogHandler createLogandler();\n    }\n{% endcodeblock %}\n具体实现,还拿拆条任务举例:\n{% codeblock  lang:java %}\n    package com.crazymonkey;\n\n    public class SplitHandlerFactory implements HandlerFactory{\n        @Override\n        public TaskHandler createTaskHandler() {\n            return new SplitTaskHandler();\n        }\n\n        @Override\n        public LogHandler createLogandler() {\n            return new SplitLogHandler();\n        }\n    }\n{% endcodeblock %}\nOk,现在我们的工厂有了两条生产线,可以生产taskHandler和logHandler,调用者该怎么做很明显了吧:\n{% codeblock  lang:java %}\n   for (Task task : taskList) {\n            //任务处理的过程 可能是代码处理/调用其他系统接口/调用其他类 在这里简单的输出一下方便处理\n            if (\"SPLIT\".equalsIgnoreCase(task.taskType)) {\n                //看这里 一个factory生产了两条线\n                HandlerFactory hf =   new SplitHandlerFactory();\n                hf.createTaskHandler().handleTask(task.targetId);\n                hf.createLogandler().handlerLog(task.targetId);\n            } else if (\"COMPSE\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"RENAME\".equalsIgnoreCase(task.taskType)) {\n            } else if (\"PUSH\".equalsIgnoreCase(task.taskType)) {\n            } else {\n                System.out.println(\"不合法的任务类型\");\n            }\n        }\n{% endcodeblock %}\n## 分析\n其实对于实现上来讲 就是扩展了一下HandlerFactory接口,加了个方法,跟以前没啥区别,但是整个的设计思想实际上是有一个更深的抽象,因此叫抽象工厂(个人理解)\n## 总结\n设计模式第一篇,总结了一个工作中常用的工厂模式,举了一个实际工作中的例子作为参考.模式类图网上有的是,可以随便找一个看看,可以加深理论上的理解,其实所有的设计模式思想都是相通的,高内聚,低耦合,面相接口编程,单一职责.用到工厂的情况还有很多种,比如处理不同的数据,翻译不同的参数关键一点就是抽象出要生产的Product,其他的问题就套模式就好了.OK,这篇文章就这样,有问题关注公众号留言.","categories":["设计模式"]},{"title":"设计模式--建造者","url":"/2019/04/11/设计模式-建造者/"},{"title":"设计模式--单例","url":"/2019/04/11/设计模式-单例/"},{"title":"Mysql索引原理--树形结构的应用","url":"/2019/04/10/Mysql索引原理-树形结构的应用/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--B树和B+树","url":"/2019/04/10/Mysql索引原理-B树和B-树/","tags":["MySQL","数据库索引"],"categories":["MySQL"]},{"title":"Mysql索引原理--树结构的基本概念","url":"/2019/04/10/Mysql索引原理-树结构的基本概念/","content":"### 写在前面\n&emsp;&emsp;这个系列的文章主要目的就是了解Mysql常用的InnoDB存储引擎的Btree类型索引的内部实现原理.在这之前先了解一下什么是树形结构吧,循序渐近别着急.\n&emsp;&emsp;树形结构实际上就是众多数据结构中的一种,什么是数据结构呢,就是组织数据的方式,什么是数据的组织方式呢?现代社会,我们生活被各种数据包围,知乎看到的文章,游戏刷出来的装备,去超市看到的薯片的配料表,杨二狗涨了300块钱工资...数据的使命就是被消费,说白了就是存储和查找.怎么存的更省地方,怎么找的更快,数据怎么尽可能快速有效的被消费.有一帮人绞尽脑汁的想出了各种各样的数据组织方式,对现实世界的应用场景进行抽象,各种数据结构就产生了,树型结构就是其中的一种,是对一种非线形关系的抽象.\n\n### 基本概念\n<div style='text-align:center'>\n\t<img width=300 src=\"Mysql索引原理--树结构的基本概念/simpletree.png\" >\n</div>\n- 根节点:A就是树的根节点 一棵树的根节点数目可以是0(空树)或1\n- 父节点/父亲节点/双亲节点:当前节点的上一级节点 B就是C的父节点 A是B的父节点\n- 子节点/孩子节点:和父节点相对应 C\n- 兄弟节点:\n- 祖先:\n- 子孙:\n- 度:\n- 层:\n- 高度:\n- 森林\n\n### 树的种类及特性\n\n\n### 树的存储表示\n<!--\n{% codeblock [测试代码] [lang:java]  %}\n\tpublic class Test(){\n\t\tpublic static void main(String [] args){\n\n\n\t}\n\n\n\t}\n\n\t\n{% endcodeblock %}\n-->\n\n\n\n\n\n<!-- <img width=200 src=\"Mysql索引原理--树结构的基本概念/1553657360617.jpg\" >  -->\n\n","tags":["MySQL","数据库索引"],"categories":["MySQL"]}]